{
  "language": "Solidity",
  "sources": {
    "contracts/agent/facets/BillingFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\n\nimport '../../nft/interfaces/IERC1155Rewardable.sol';\nimport '../../shared/lib/LibPausable.sol';\nimport '../../shared/lib/Util.sol';\nimport '../lib/AppStorage.sol';\nimport '../lib/BillingStorage.sol';\n\n/**\n * @title BillingFacet\n * @author Shu Dong\n * @notice billing related functions\n */\ncontract BillingFacet is PausableModifier, OwnableInternal {\n    AppStorage internal s;\n\n    using SafeERC20 for IERC20;\n\n    event RewardTokenSold(address indexed billing, uint sold, uint paid);\n    event CloseBilling(uint indexed billing);\n    event BillingSale(uint indexed, uint expireAt);\n    event LockPrice(uint indexed, uint indexed);\n    event Withdraw(address indexed recipient, uint amount);\n\n    /**\n     * @notice withdraw payment from contract\n     * @param recipient Address of account to accept payment\n     * @param amount Amount to withdraw\n     */\n    function withdraw(address recipient, uint amount) external onlyOwner {\n        s.payment.safeTransfer(recipient, amount);\n        emit Withdraw(recipient, amount);\n    }\n\n    /**\n     * @notice It will try to sell income token at Uniswap\n     * to pay bill and start income token sale if it fails\n     */\n    function tryBilling() external onlyOwner {\n        BillingStorage.Layout storage l = BillingStorage.layout();\n        require(\n            l.stage == BillingStorage.Stage.NOT_STARTED,\n            'DeMineAgent: billing in progress'\n        );\n        uint billing = s.billing;\n        IERC1155Rewardable nft = s.nft;\n        uint balance = nft.balanceOf(address(this), billing);\n        uint debt = s.tokenCost * balance;\n        if (debt == 0) {\n            close(l, billing);\n            return;\n        }\n        address alchemist = nft.alchemist();\n        uint prevBalance = s.income.balanceOf(address(this));\n        nft.safeTransferFrom(\n            address(this), alchemist, billing, balance, ''\n        );\n        uint income = s.income.balanceOf(address(this)) - prevBalance;\n        if (income == 0) {\n            s.statements[billing].balance = balance;\n            s.statements[billing].debt = debt;\n            s.deposit -= s.statements[billing].debt;\n            close(l, billing);\n            return;\n        }\n        (bool success, uint sold) = trySwap(\n            l.swapRouter, address(s.income), address(s.payment), income, debt\n        );\n        if (success) {\n            s.statements[billing].balance = balance;\n            s.statements[billing].income = income - sold;\n            close(l, billing);\n        } else {\n            s.statements[billing] = Statement(balance, income, debt);\n            uint saleExpireAt = block.timestamp + l.saleDuration;\n            l.saleExpireAt = saleExpireAt;\n            l.stage = BillingStorage.Stage.SALE_ONGOING;\n            emit BillingSale(billing, saleExpireAt);\n        }\n    }\n\n    /**\n     * @notice lock price to buy income token in income token sale\n     */\n    function lockPrice() external returns(uint unitSize, uint unitPrice) {\n        BillingStorage.Layout storage l = BillingStorage.layout();\n        require(\n            l.stage == BillingStorage.Stage.SALE_ONGOING,\n            'DeMineAgent: no sale on-going'\n        );\n        Statement memory st = s.statements[s.billing];\n        uint price = getNormalizedChainlinkPriceWithDiscount(l);\n        uint incomeBase = base(s.income);\n        uint maxCostTokenTraded = price * st.income / incomeBase;\n        (unitSize, unitPrice) = maxCostTokenTraded > st.debt\n            ? calcUnitPrice(price, incomeBase)\n            : calcUnitPrice(st.debt, st.income);\n        l.lockedPrices[msg.sender] = BillingStorage.LockedPrice(\n            unitSize, unitPrice, block.timestamp + l.priceLockDuration\n        );\n        emit LockPrice(unitSize, unitPrice);\n    }\n\n    /**\n     * @notice buy income token with locked price\n     * @param maxToPay The max amount of cost to pay\n     */\n    function buyWithLockedPrice(uint maxToPay) external {\n        BillingStorage.Layout storage l = BillingStorage.layout();\n        require(\n            l.stage == BillingStorage.Stage.SALE_ONGOING,\n            'DeMineAgent: no sale on-going'\n        );\n        BillingStorage.LockedPrice memory p = l.lockedPrices[msg.sender];\n        require(block.timestamp < p.expireAt, 'DeMineAgent: price expired');\n        uint billing = s.billing;\n        Statement memory st = s.statements[billing];\n        uint unitToBuy = Util.min3(\n            maxToPay / p.unitPrice,\n            Util.ceil(st.debt, p.unitPrice),\n            st.income / p.unitSize\n        );\n        uint checkout = unitToBuy * p.unitPrice;\n        uint rewardTokenSold = unitToBuy * p.unitSize;\n        s.statements[billing].income = st.income - rewardTokenSold;\n        if (checkout < st.debt) {\n            s.statements[billing].debt = st.debt - checkout;\n        } else {\n            s.statements[billing].debt = 0;\n            close(l, s.billing);\n        }\n        s.payment.safeTransferFrom(msg.sender, s.payee, checkout);\n        s.income.safeTransfer(msg.sender, rewardTokenSold);\n        emit RewardTokenSold(msg.sender, rewardTokenSold, checkout);\n    }\n\n    function manualCloseBilling() external onlyOwner {\n        BillingStorage.Layout storage l = BillingStorage.layout();\n        BillingStorage.Stage stage = l.stage;\n        require(\n            stage == BillingStorage.Stage.SALE_ONGOING &&\n                block.timestamp > l.saleExpireAt,\n            'DeMineAgent: no action required yet'\n        );\n        uint billing = s.billing;\n        s.deposit -= s.statements[s.billing].debt;\n        close(l, billing);\n    }\n\n    /**\n     * @notice Collect income leftover, no waste\n     */\n    function collectResidue(\n        address recipient,\n        uint start,\n        uint end\n    ) external onlyOwner {\n        require(end < s.billing, 'DeMineAgent: token not billed yet');\n        uint total;\n        for (uint id = start; id <= end; id++) {\n            uint income = s.statements[s.billing].income;\n            uint balance = s.statements[s.billing].income;\n            total += income - (income / balance) * balance;\n        }\n        s.income.safeTransferFrom(address(this), recipient, total);\n    }\n\n    function getStatement(uint token) external view returns(Statement memory) {\n        return s.statements[token];\n    }\n\n    function trySwap(\n        address swapRouter,\n        address tokenIn,\n        address tokenOut,\n        uint amountInMaximum,\n        uint amountOut\n    ) internal returns(bool, uint) {\n        TransferHelper.safeApprove(tokenIn, swapRouter, amountInMaximum);\n        ISwapRouter.ExactOutputSingleParams memory param =\n            ISwapRouter.ExactOutputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: 3000, // 0.3%\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountOut: amountOut,\n                amountInMaximum: amountInMaximum,\n                sqrtPriceLimitX96: 0\n        });\n        (bool success, bytes memory encoded) = swapRouter.call(\n            abi.encodeWithSignature(\n                'exactOutputSingle((address,address,uint24,address,uint,uiint256,uint,uint160))',\n                param\n            )\n        );\n        TransferHelper.safeApprove(tokenIn, swapRouter, 0);\n        if (success) {\n            (uint amountIn) = abi.decode(encoded, (uint));\n            return (true, amountIn);\n        } else {\n            return (false, 0);\n        }\n    }\n\n    function getNormalizedChainlinkPriceWithDiscount(\n        BillingStorage.Layout storage l\n    ) private view returns(uint) {\n        (,int price, , ,) = l.chainlink.latestRoundData();\n        if (price <= 0) { return 0; }\n        uint chainlinkBase = 10 ** (l.chainlink.decimals());\n        uint normalized = uint(price) * base(s.payment) / chainlinkBase;\n        return normalized * l.discount / 10000;\n    }\n\n    function base(IERC20 token) private view returns(uint) {\n        uint8 decimals = IERC20Metadata(address(token)).decimals();\n        return 10 ** decimals;\n    }\n\n    function calcUnitPrice(\n          uint cost,\n          uint income\n    ) private pure returns(uint, uint) {\n        if (cost > income) {\n            /**\n              cost = 100, income = 1000, then unit = 10, price = 1,\n              which means you have to buy at least 10 income tokens\n              each time and each unit cost 1 cost token\n            */\n            return (1, Util.ceil(cost, income));\n        } else {\n            /**\n              cost = 1000, income = 100, then unit = 1, price = 10,\n              which means you can buy at least 1 income token each\n              time and each income token cost 10 cost token\n            */\n            uint unitSize = Util.ceil(income, cost);\n            return (unitSize, Util.ceil(cost, income / unitSize));\n        }\n    }\n\n    function close(BillingStorage.Layout storage l, uint billing) private {\n        s.billing = billing + 1;\n        l.stage = BillingStorage.Stage.NOT_STARTED;\n        emit CloseBilling(billing);\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/nft/interfaces/IERC1155Rewardable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\n\ninterface IERC1155Rewardable is IERC1155 {\n    function alchemist() external view returns(address);\n\n    function earningToken() external view returns(address);\n}\n"
    },
    "contracts/shared/lib/LibPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport '../interfaces/IPausable.sol';\n\nlibrary LibPausable {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract PausableModifier {\n    modifier whenPaused() {\n        require(LibPausable.layout().paused, 'Pausable: not paused');\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!LibPausable.layout().paused, 'Pausable: paused');\n        _;\n    }\n}\n\nabstract contract Pausable is IPausable, OwnableInternal {\n    function paused() external override view returns (bool) {\n        return LibPausable.layout().paused;\n    }\n\n    function pause() external onlyOwner override {\n        LibPausable.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyOwner override {\n        LibPausable.layout().paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "contracts/shared/lib/Util.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary Util {\n    function ceil(uint a, uint m) internal pure returns(uint) {\n        return ((a + m - 1) / m) * m;\n    }\n\n    function max3(uint a, uint b, uint c) internal pure returns(uint) {\n        return a > b ? max2(a, c) : max2(b, c);\n    }\n\n    function max2(uint a, uint b) internal pure returns(uint) {\n        return a > b ? a : b;\n    }\n\n    function min2(uint a, uint b) internal pure returns(uint) {\n        return a < b ? a : b;\n    }\n\n    function min3(uint a, uint b, uint c) internal pure returns(uint) {\n        return a < b ? min2(a, c) : min2(b, c);\n    }\n}\n"
    },
    "contracts/agent/lib/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport '../../nft/interfaces/IERC1155Rewardable.sol';\n\nstruct Account {\n    uint start; // starting from 2**256 - 1 - start\n    uint end;\n    uint maxBalance;\n}\n\nstruct Statement {\n    uint balance;\n    uint income;\n    uint debt;\n}\n\nstruct AppStorage {\n    uint tokenCost; // cost per nft in cost token\n\n    IERC20 income;\n    IERC20 payment;\n    IERC1155Rewardable nft; // DeMineNFT contract address\n    address payee; // payee account address, could be contract\n\n    bool initialized;\n    uint8 depositMultiplier; // deposit = maxBalance * tokenCost * depositMultiplier\n    uint deposit; // total deposit in cost token\n    uint billing; // current billing token\n    // billing statement\n    mapping(uint => Statement) statements;\n    // account info\n    mapping(address => Account) accounts;\n    // tokenId => account => price\n    mapping(uint => mapping(address => uint)) balances;\n    // owner => buyer => allowance\n    mapping(address => mapping(address => mapping(uint => uint))) allowances;\n}\n"
    },
    "contracts/agent/lib/BillingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary BillingStorage {\n    enum Stage{ NOT_STARTED, SALE_ONGOING }\n\n    struct LockedPrice {\n        uint unitSize;\n        uint unitPrice;\n        uint expireAt;\n    }\n\n    struct Layout {\n        AggregatorV3Interface chainlink;\n        address swapRouter;\n        Stage stage;\n        uint8 shrinkSize; // num of tokens we shrink starting from mining\n        uint16 discount; // 10000 based\n        uint16 saleDuration; // as second\n        uint16 priceLockDuration; // as second\n        uint shrinked; // latest token shrinked\n        uint saleExpireAt; // timestamp\n        mapping(address => LockedPrice) lockedPrices;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.agent.contracts.storage.Billing');\n\n    function layout() internal pure returns(Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155Internal } from './IERC1155Internal.sol';\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IPausable {\n    /**\n     * @dev Emitted when paused by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when unpaused by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Should return if the contract is paused\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @dev pause the contract\n     */\n    function pause() external;\n\n    /**\n     * @dev unpause the contract\n     */\n    function unpause() external;\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/agent/facets/MortgageFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/introspection/ERC165.sol';\nimport '@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol';\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport '../../shared/lib/Util.sol';\nimport '../../shared/lib/LibPausable.sol';\nimport '../lib/AppStorage.sol';\nimport '../lib/BillingStorage.sol';\nimport '../../shared/lib/DiamondFallback.sol';\n\n/**\n * @title MortgageFacet\n * @author Shu Dong\n * @notice Facet contract holding functions for miners to manage mortgage.\n * @dev the contract also implements IERC1155Receiver to receive and lock demine nft\n */\ncontract MortgageFacet is\n    DiamondFallback,\n    PausableModifier,\n    IERC1155Receiver,\n    ERC165\n{\n    AppStorage internal s;\n\n    using SafeERC20 for IERC20;\n\n    event Redeem(address indexed, uint[], uint[]);\n\n    function init(bytes memory args) internal override onlyInitializing {\n        (address nft, address payment, address payee, uint tokenCost) =\n            abi.decode(args, (address, address, address, uint));\n        IERC1155Rewardable nftContract = IERC1155Rewardable(nft);\n        s.nft = nftContract;\n        s.income = IERC20(nftContract.earningToken());\n        s.payment = IERC20(payment);\n        s.payee = payee;\n        s.tokenCost = tokenCost;\n    }\n\n    /**\n     * @notice Pay token cost and liquidize tokens\n     * @param ids DeMine nft token ids to redeem\n     * @param amounts Amount of each demine nft token\n     */\n    function redeem(\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) external whenNotPaused {\n        require(\n            ids.length == amounts.length,\n            \"DeMineAgent: array length mismatch\"\n        );\n        uint tokenCost = s.tokenCost;\n        uint billing = s.billing;\n        uint totalCost;\n        for (uint i = 0; i < ids.length; i++) {\n            require(ids[i] >= billing, 'DeMineAgent: token not redeemable');\n            totalCost += tokenCost * amounts[i];\n            uint balance = s.balances[ids[i]][msg.sender];\n            require(balance > amounts[i], 'DeMineAgent: no sufficient balance');\n            s.balances[ids[i]][msg.sender] = balance - amounts[i];\n        }\n        s.payment.safeTransferFrom(msg.sender, s.payee, totalCost);\n        emit Redeem(msg.sender, ids, amounts);\n        s.nft.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    /**\n     * @notice adjust deposit for msg sender and update account info\n     *         Ensure you have a valid start and end set for msg.sender\n     *         to prevent infinite loop\n     */\n    function adjustDeposit() external whenNotPaused {\n        Account memory account = readAccount(msg.sender);\n        require(account.start >= s.billing, 'DeMineAgent: payoff debt first');\n        require(account.maxBalance > 0, 'DeMineAgent: no need to adjust');\n\n        Account memory update = Account(account.start, account.end, 0);\n        while (s.balances[update.start][msg.sender] == 0 && update.start <= update.end) {\n            update.start += 1;\n        }\n        while (s.balances[update.end][msg.sender] == 0 && update.end >= update.start) {\n            update.end -= 1;\n        }\n        if (update.start > update.end) {\n            updateAccount(msg.sender, account, Account(type(uint).max, 0, 0));\n        } else {\n            for (uint id = update.start; id <= update.end; id++) {\n                update.maxBalance = Util.max2(update.maxBalance, s.balances[id][msg.sender]);\n            }\n            updateAccount(msg.sender, account, update);\n        }\n    }\n\n    /**\n     * @notice get account info\n     * @param account Address of account to query\n     */\n    function getAccountInfo(address account) external view returns(Account memory) {\n        return s.accounts[account];\n    }\n\n    function balanceOfBatch(\n        address account,\n        uint[] calldata ids\n    ) external view returns(uint[] memory) {\n        uint[] memory balances = new uint[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            balances[i] = s.balances[ids[i]][account];\n        }\n        return balances;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0; // reject\n    }\n\n    // @dev the function should only be called by mint function of DeMineNFT\n    // @param from Must be address(0)\n    // @param data Must be encoded address of mortagager\n    function onERC1155BatchReceived(\n        address,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(\n            msg.sender == address(s.nft) && from == address(0),\n            'DeMineAgent: only minted tokens from DeMineNFT allowed'\n        );\n        (address mortgager) = abi.decode(data, (address));\n        Account memory account = readAccount(mortgager);\n        Account memory update = Account(type(uint).max, 0, 0);\n        for (uint i = 0; i < ids.length; i++) {\n            uint balance = s.balances[ids[i]][mortgager] + amounts[i];\n            s.balances[ids[i]][mortgager] = balance;\n            update.maxBalance = Util.max2(balance, update.maxBalance);\n            update.start = Util.min2(ids[i], update.start);\n            update.end = Util.max2(ids[i], update.end);\n        }\n        mergeAccount(mortgager, account, update);\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @notice payoff debt from start to end. Ensure you have a\n     *         valid start set to prevent infinite loop\n     */\n    function payoff(uint end) external whenNotPaused {\n        uint income;\n        uint debt;\n        Account memory account = readAccount(msg.sender);\n        require(end < s.billing, 'DeMineAgent: end larger than billing');\n        for (uint id = account.start; id <= end; id++) {\n            uint balance = s.balances[id][msg.sender];\n            if (balance > 0) {\n                Statement memory st = s.statements[id];\n                income += st.income * balance / st.balance;\n                debt += Util.ceil(st.debt * balance, st.balance);\n                s.balances[id][msg.sender] = 0;\n            }\n        }\n        s.accounts[msg.sender].start = end + 1;\n        s.payment.safeTransferFrom(s.payee, msg.sender, debt);\n        s.deposit += debt;\n        s.income.safeTransfer(msg.sender, income);\n    }\n\n    function readAccount(\n        address account\n    ) private view returns(Account memory acc) {\n        acc = s.accounts[account];\n        acc.start = type(uint).max - acc.start;\n        return acc;\n    }\n\n    function updateAccount(\n        address account,\n        Account memory current,\n        Account memory update\n    ) private {\n        if (update.start > current.start) {\n            s.accounts[account].start = type(uint).max - update.start;\n        }\n        if (update.end < current.end) {\n            s.accounts[account].end = update.end;\n        }\n        if (update.maxBalance < current.maxBalance) {\n            s.accounts[account].maxBalance = update.maxBalance;\n            uint delta = (current.maxBalance - update.maxBalance) * depositBase();\n            s.payment.safeTransfer(account, delta);\n            s.deposit -= delta;\n        }\n    }\n\n    function mergeAccount(\n        address account,\n        Account memory current,\n        Account memory update\n    ) private {\n        if (update.start < current.start) {\n            s.accounts[account].start = type(uint).max - update.start;\n            current.start = update.start;\n        }\n        if (update.end > current.end) {\n            s.accounts[account].start = update.start;\n            current.end = update.end;\n        }\n        if (update.maxBalance > current.maxBalance) {\n            s.accounts[account].maxBalance = update.maxBalance;\n            current.maxBalance = update.maxBalance;\n            uint delta = (update.maxBalance - current.maxBalance) * depositBase();\n            s.payment.safeTransferFrom(msg.sender, s.payee, delta);\n            s.deposit += delta;\n        }\n    }\n\n    function depositBase() private view returns(uint) {\n        return s.tokenCost * s.depositMultiplier;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from './IERC165.sol';\nimport { ERC165Storage } from './ERC165Storage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n    using ERC165Storage for ERC165Storage.Layout;\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/shared/lib/DiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './LibInitializable.sol';\n\nabstract contract DiamondFallback is Initializable {\n    function init(bytes memory args) internal virtual;\n\n    function __DiamondFallback_init(bytes memory args) external onlyInitializing {\n        init(args);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "contracts/shared/lib/LibInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/utils/AddressUtils.sol';\n\n/**\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary InitializableStorage {\n    struct Layout {\n        bool initialized;\n        bool initializing;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.contracts.storage.Initializable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract Initializable {\n    modifier initializer() {\n        InitializableStorage.Layout storage l = InitializableStorage.layout();\n        require(\n            l.initializing ? isConstructor() : !l.initialized,\n            'Initializable: contract is already initialized'\n        );\n        bool isTopLevelCall = !l.initializing;\n        if (isTopLevelCall) {\n            l.initializing = true;\n            l.initialized = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            l.initializing = false;\n        }\n    }\n\n    modifier onlyInitializing() {\n        require(\n            InitializableStorage.layout().initializing,\n            'Initializable: contract is not initializing'\n        );\n        _;\n    }\n\n    function isConstructor() private view returns (bool) {\n        return !AddressUtils.isContract(address(this));\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "contracts/wrapped/facets/ERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport '@solidstate/contracts/token/ERC20/ERC20.sol';\nimport '@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol';\n\nimport '../../shared/lib/DiamondFallback.sol';\n\ncontract ERC20Facet is ERC20, DiamondFallback, OwnableInternal {\n    function init(bytes memory args) internal override {\n        (string memory name, string memory symbol, uint8 decimals) =\n            abi.decode(args, (string, string, uint8));\n        ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\n        l.name = name;\n        l.symbol = symbol;\n        l.decimals = decimals;\n    }\n\n    function burn(uint256 amount) external onlyOwner {\n        _burn(msg.sender, amount);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20Base } from './base/ERC20Base.sol';\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\n\n/**\n * @title SolidState ERC20 implementation, including recommended extensions\n */\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setName(Layout storage l, string memory name) internal {\n        l.name = name;\n    }\n\n    function setSymbol(Layout storage l, string memory symbol) internal {\n        l.symbol = symbol;\n    }\n\n    function setDecimals(Layout storage l, uint8 decimals) internal {\n        l.decimals = decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from '../IERC20.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(address holder, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = ERC20BaseStorage.layout().allowances[holder][\n            msg.sender\n        ];\n        require(\n            currentAllowance >= amount,\n            'ERC20: transfer amount exceeds allowance'\n        );\n        unchecked {\n            _approve(holder, msg.sender, currentAllowance - amount);\n        }\n        _transfer(holder, recipient, amount);\n        return true;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20Base, ERC20BaseStorage } from '../base/ERC20Base.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is ERC20Base {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        unchecked {\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\n                .layout()\n                .allowances[msg.sender];\n\n            uint256 allowance = allowances[spender];\n            require(\n                allowance + amount >= allowance,\n                'ERC20Extended: excessive allowance'\n            );\n\n            _approve(\n                msg.sender,\n                spender,\n                allowances[spender] = allowance + amount\n            );\n\n            return true;\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        unchecked {\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\n                .layout()\n                .allowances[msg.sender];\n\n            uint256 allowance = allowances[spender];\n            require(\n                amount <= allowance,\n                'ERC20Extended: insufficient allowance'\n            );\n\n            _approve(\n                msg.sender,\n                spender,\n                allowances[spender] = allowance - amount\n            );\n\n            return true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\nimport { IERC20Metadata } from './IERC20Metadata.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() public view virtual override returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(address holder, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Internal } from '../IERC20Internal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(address account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        require(balance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        require(\n            holderBalance >= amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondCuttable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableInternal } from '../../access/OwnableInternal.sol';\nimport { IDiamondCuttable } from './IDiamondCuttable.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy update contract\n */\nabstract contract DiamondCuttable is IDiamondCuttable, OwnableInternal {\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external override onlyOwner {\n        DiamondBaseStorage.layout().diamondCut(facetCuts, target, data);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/IDiamondCuttable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Diamond proxy upgrade interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondCuttable {\n    enum FacetCutAction {\n        ADD,\n        REPLACE,\n        REMOVE\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\n\n    struct FacetCut {\n        address target;\n        FacetCutAction action;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice update diamond facets and optionally execute arbitrary initialization function\n     * @param facetCuts facet addresses, actions, and function selectors\n     * @param target initialization function target\n     * @param data initialization function call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IDiamondCuttable } from './IDiamondCuttable.sol';\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    using AddressUtils for address;\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    event DiamondCut(\n        IDiamondCuttable.FacetCut[] facetCuts,\n        address target,\n        bytes data\n    );\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param l storage layout\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function diamondCut(\n        Layout storage l,\n        IDiamondCuttable.FacetCut[] memory facetCuts,\n        address target,\n        bytes memory data\n    ) internal {\n        unchecked {\n            uint256 originalSelectorCount = l.selectorCount;\n            uint256 selectorCount = originalSelectorCount;\n            bytes32 selectorSlot;\n\n            // Check if last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                // get last selectorSlot\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\n            }\n\n            for (uint256 i; i < facetCuts.length; i++) {\n                IDiamondCuttable.FacetCut memory facetCut = facetCuts[i];\n                IDiamondCuttable.FacetCutAction action = facetCut.action;\n\n                require(\n                    facetCut.selectors.length > 0,\n                    'DiamondBase: no selectors specified'\n                );\n\n                if (action == IDiamondCuttable.FacetCutAction.ADD) {\n                    (selectorCount, selectorSlot) = l.addFacetSelectors(\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                } else if (action == IDiamondCuttable.FacetCutAction.REPLACE) {\n                    l.replaceFacetSelectors(facetCut);\n                } else if (action == IDiamondCuttable.FacetCutAction.REMOVE) {\n                    (selectorCount, selectorSlot) = l.removeFacetSelectors(\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                }\n            }\n\n            if (selectorCount != originalSelectorCount) {\n                l.selectorCount = uint16(selectorCount);\n            }\n\n            // If last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\n            }\n\n            emit DiamondCut(facetCuts, target, data);\n            initialize(target, data);\n        }\n    }\n\n    function addFacetSelectors(\n        Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        IDiamondCuttable.FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            require(\n                facetCut.target == address(this) ||\n                    facetCut.target.isContract(),\n                'DiamondBase: ADD target has no code'\n            );\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    'DiamondBase: selector already added'\n                );\n\n                // add facet for selector\n                l.facets[selector] =\n                    bytes20(facetCut.target) |\n                    bytes32(selectorCount);\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\n\n                // clear selector position in slot and add selector\n                selectorSlot =\n                    (selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\n                    selectorSlot = 0;\n                }\n\n                selectorCount++;\n            }\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function removeFacetSelectors(\n        Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        IDiamondCuttable.FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            require(\n                facetCut.target == address(0),\n                'DiamondBase: REMOVE target must be zero address'\n            );\n\n            uint256 selectorSlotCount = selectorCount >> 3;\n            uint256 selectorInSlotIndex = selectorCount & 7;\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                require(\n                    address(bytes20(oldFacet)) != address(0),\n                    'DiamondBase: selector not found'\n                );\n\n                require(\n                    address(bytes20(oldFacet)) != address(this),\n                    'DiamondBase: selector is immutable'\n                );\n\n                if (selectorSlot == 0) {\n                    selectorSlotCount--;\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                // adding a block here prevents stack too deep error\n                {\n                    // replace selector with last selector in l.facets\n                    lastSelector = bytes4(\n                        selectorSlot << (selectorInSlotIndex << 5)\n                    );\n\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        l.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(l.facets[lastSelector]);\n                    }\n\n                    delete l.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = l.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    // update storage with the modified slot\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    selectorSlot =\n                        (selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete l.selectorSlots[selectorSlotCount];\n                    selectorSlot = 0;\n                }\n            }\n\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function replaceFacetSelectors(\n        Layout storage l,\n        IDiamondCuttable.FacetCut memory facetCut\n    ) internal {\n        unchecked {\n            require(\n                facetCut.target.isContract(),\n                'DiamondBase: REPLACE target has no code'\n            );\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                require(\n                    oldFacetAddress != address(0),\n                    'DiamondBase: selector not found'\n                );\n\n                require(\n                    oldFacetAddress != address(this),\n                    'DiamondBase: selector is immutable'\n                );\n\n                require(\n                    oldFacetAddress != facetCut.target,\n                    'DiamondBase: REPLACE target is identical'\n                );\n\n                // replace old facet address\n                l.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(facetCut.target);\n            }\n        }\n    }\n\n    function initialize(address target, bytes memory data) private {\n        require(\n            (target == address(0)) == (data.length == 0),\n            'DiamondBase: invalid initialization parameters'\n        );\n\n        if (target != address(0)) {\n            if (target != address(this)) {\n                require(\n                    target.isContract(),\n                    'DiamondBase: initialization target has no code'\n                );\n            }\n\n            (bool success, ) = target.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\nimport { IDiamondLoupe } from './IDiamondLoupe.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy introspection contract\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nabstract contract DiamondLoupe is IDiamondLoupe {\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facets()\n        external\n        view\n        override\n        returns (Facet[] memory diamondFacets)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        diamondFacets = new Facet[](l.selectorCount);\n\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (diamondFacets[facetIndex].target == facet) {\n                        diamondFacets[facetIndex].selectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                diamondFacets[numFacets].target = facet;\n                diamondFacets[numFacets].selectors = new bytes4[](\n                    l.selectorCount\n                );\n                diamondFacets[numFacets].selectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\n\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        // setting the number of facets\n        assembly {\n            mstore(diamondFacets, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facetFunctionSelectors(address facet)\n        external\n        view\n        override\n        returns (bytes4[] memory selectors)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        selectors = new bytes4[](l.selectorCount);\n\n        uint256 numSelectors;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\n                if (facet == address(bytes20(l.facets[selector]))) {\n                    selectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        // set the number of selectors in the array\n        assembly {\n            mstore(selectors, numSelectors)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory addresses)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        addresses = new address[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facet == addresses[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                addresses[numFacets] = facet;\n                numFacets++;\n            }\n        }\n\n        // set the number of facet addresses in the array\n        assembly {\n            mstore(addresses, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facetAddress(bytes4 selector)\n        external\n        view\n        override\n        returns (address facet)\n    {\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondLoupe {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(address facet)\n        external\n        view\n        returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(bytes4 selector)\n        external\n        view\n        returns (address facet);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Proxy } from '../Proxy.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\nimport { IDiamondLoupe } from './IDiamondLoupe.sol';\nimport { IDiamondCuttable } from './IDiamondCuttable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy base contract\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\nabstract contract DiamondBase is Proxy {\n    /**\n     * @inheritdoc Proxy\n     */\n    function _getImplementation() internal view override returns (address) {\n        // inline storage layout retrieval uses less gas\n        DiamondBaseStorage.Layout storage l;\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n\n        address implementation = address(bytes20(l.facets[msg.sig]));\n\n        if (implementation == address(0)) {\n            implementation = l.fallbackAddress;\n            require(\n                implementation != address(0),\n                'DiamondBase: no facet found for function signature'\n            );\n        }\n\n        return implementation;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        require(\n            implementation.isContract(),\n            'Proxy: implementation must be contract'\n        );\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC1155Internal } from '../IERC1155Internal.sol';\nimport { IERC1155Receiver } from '../IERC1155Receiver.sol';\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155Internal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            'ERC1155: balance query for the zero address'\n        );\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: mint to the zero address');\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n        balances[account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: mint to the zero address');\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; i++) {\n            balances[ids[i]][account] += amounts[i];\n        }\n\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _safeMintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _mintBatch(account, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice burn given quantity of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param id token ID\n     * @param amount quantity of tokens to burn\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: burn from the zero address');\n\n        _beforeTokenTransfer(\n            msg.sender,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            ''\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n\n        unchecked {\n            require(\n                balances[account] >= amount,\n                'ERC1155: burn amount exceeds balances'\n            );\n            balances[account] -= amount;\n        }\n\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\n    }\n\n    /**\n     * @notice burn given batch of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param ids token IDs\n     * @param amounts quantities of tokens to burn\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: burn from the zero address');\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            for (uint256 i; i < ids.length; i++) {\n                uint256 id = ids[i];\n                require(\n                    balances[id][account] >= amounts[i],\n                    'ERC1155: burn amount exceeds balance'\n                );\n                balances[id][account] -= amounts[i];\n            }\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(\n            recipient != address(0),\n            'ERC1155: transfer to the zero address'\n        );\n\n        _beforeTokenTransfer(\n            operator,\n            sender,\n            recipient,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            require(\n                senderBalance >= amount,\n                'ERC1155: insufficient balances for transfer'\n            );\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(\n            recipient != address(0),\n            'ERC1155: transfer to the zero address'\n        );\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; i++) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n                require(\n                    senderBalance >= amount,\n                    'ERC1155: insufficient balances for transfer'\n                );\n                balances[token][sender] = senderBalance - amount;\n            }\n\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(uint256 element)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                require(\n                    response == IERC1155Receiver.onERC1155Received.selector,\n                    'ERC1155: ERC1155Receiver rejected tokens'\n                );\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert('ERC1155: transfer to non ERC1155Receiver implementer');\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                require(\n                    response ==\n                        IERC1155Receiver.onERC1155BatchReceived.selector,\n                    'ERC1155: ERC1155Receiver rejected tokens'\n                );\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert('ERC1155: transfer to non ERC1155Receiver implementer');\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 => mapping(address => uint256)) balances;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155 } from '../IERC1155.sol';\nimport { IERC1155Receiver } from '../IERC1155Receiver.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from './ERC1155BaseInternal.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155, ERC1155BaseInternal {\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balanceOf(account, id);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            'ERC1155: accounts and ids length mismatch'\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; i++) {\n                require(\n                    accounts[i] != address(0),\n                    'ERC1155: batch balance query for the zero address'\n                );\n                batchBalances[i] = balances[ids[i]][accounts[i]];\n            }\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function setApprovalForAll(address operator, bool status)\n        public\n        virtual\n        override\n    {\n        require(\n            msg.sender != operator,\n            'ERC1155: setting approval status for self'\n        );\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: caller is not owner nor approved'\n        );\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: caller is not owner nor approved'\n        );\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "contracts/nft/facets/ERC1155Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/introspection/ERC165.sol';\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\nimport '@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol';\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport '../../shared/lib/DiamondFallback.sol';\nimport '../../shared/lib/LibPausable.sol';\nimport './MiningOracle.sol';\nimport './ERC1155Config.sol';\n\ncontract ERC1155Facet is\n    DiamondFallback,\n    ERC1155Base,\n    MiningOracle,\n    ERC1155Config,\n    ERC165\n{\n    using SafeERC20 for IERC20;\n\n    event Alchemy(address indexed account, uint totalEarning);\n\n    function init(bytes memory args) internal override onlyInitializing {\n        (\n            address recipient,\n            uint16 bps,\n            address earningTokenAdd,\n            string memory uri\n        ) = abi.decode(args, (address, uint16, address, string));\n        s.royalty = RoyaltyInfo(recipient, bps);\n        s.earningToken = IERC20(earningTokenAdd);\n        _setBaseURI(uri);\n    }\n\n    function mintBatch(\n        address account,\n        uint[] calldata ids,\n        uint[] calldata amounts,\n        bytes memory data\n    ) external onlyOwner {\n        _safeMintBatch(account, ids, amounts, data);\n    }\n\n    function burnBatch(\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) external onlyOwner {\n        _burnBatch(msg.sender, ids, amounts);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint[] memory ids,\n        uint[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155BaseInternal) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n        address alchemist = _alchemist();\n        require(from != alchemist, 'DeMineNFT: from alchemist');\n        // alchemize\n        if (to == alchemist) {\n            require(!LibPausable.layout().paused, 'Pausable: paused');\n            uint totalEarning;\n            uint finalized = s.finalized;\n            for (uint i; i < ids.length; i++) {\n                (uint128 start, uint128 end) = decode(ids[i]);\n                require(end <= finalized, 'DeMineNFT: token not finalized yet');\n                totalEarning += amounts[i] * _earning(start, end);\n            }\n            s.earningToken.safeTransfer(from, totalEarning);\n            emit Alchemy(from, totalEarning);\n        }\n    }\n\n    function decode(uint tokenId) private pure returns(uint128, uint128) {\n        return (uint128(tokenId >> 128), uint128(tokenId));\n    }\n}\n"
    },
    "contracts/nft/facets/MiningOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport './Base.sol';\n\nabstract contract MiningOracle is Base {\n    event Finalize(uint128 indexed, uint);\n\n    function finalize(uint128 timestamp, uint earningPerToken) external onlyOwner {\n        require(\n            timestamp > s.finalized && timestamp % 86400 == 0,\n            'DeMineNFT: invalid timestamp'\n        );\n        s.finalized = timestamp;\n        s.daily[timestamp] = earningPerToken;\n        for(uint128 i = 0; i < 7; i++) {\n            s.weekly[timestamp + i * 86400] += earningPerToken;\n        }\n        emit Finalize(timestamp, earningPerToken);\n    }\n\n    function finalized() external view returns(uint128) {\n        return s.finalized;\n    }\n\n    function earning(uint tokenId) external view returns(uint) {\n        uint128 start = uint128(tokenId >> 128);\n        uint128 end = uint128(tokenId);\n        return _earning(start, end);\n    }\n\n    function _earning(uint128 start, uint128 end)\n        internal\n        view\n        returns(uint value)\n    {\n        // daily token\n        if (end - start == 86400) {\n            value = s.daily[end];\n        // weekly token\n        } else if (end - start == 604800) {\n            value = s.weekly[end];\n        // biweekly token\n        } else if (end - start == 1209600) {\n            value = s.weekly[end] + s.weekly[end - 604800];\n        }\n    }\n}\n"
    },
    "contracts/nft/facets/ERC1155Config.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/IERC2981.sol';\nimport '../interfaces/IERC1155Rewardable.sol';\nimport './Base.sol';\nimport '@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol';\n\nabstract contract ERC1155Config is\n    Base,\n    IERC2981,\n    IERC1155Rewardable,\n    ERC1155Metadata\n{\n    event TokenRoyaltyBpsSet(uint16);\n\n    function setURI(string memory baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function setRoyaltyInfo(address recipient, uint16 bps) external onlyOwner {\n        s.royalty = RoyaltyInfo(recipient, bps);\n        emit TokenRoyaltyBpsSet(bps);\n    }\n\n    function royaltyInfo(uint256, uint256 value)\n        external\n        view\n        override\n        returns (address, uint256)\n    {\n        RoyaltyInfo memory r = s.royalty;\n        return (r.recipient, (value * r.bps) / 10000);\n    }\n\n    function earningToken() external override view returns(address) {\n        return address(s.earningToken);\n    }\n\n    function alchemist() external override pure returns(address) {\n        return _alchemist();\n    }\n\n    function _alchemist() internal pure returns(address) {\n        return address(0x1A811678eEEDF16a1D0dF4b12e290F78a61A28F9);\n    }\n}\n"
    },
    "contracts/nft/facets/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\n\nimport '../lib/AppStorage.sol';\n\nabstract contract Base is OwnableInternal {\n    AppStorage internal s;\n}\n"
    },
    "contracts/nft/lib/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nstruct RoyaltyInfo {\n    address recipient;\n    uint16 bps;\n}\n\nstruct AppStorage {\n    IERC20 earningToken;\n    RoyaltyInfo royalty;\n\n    // Oracle\n    uint128 finalized;\n    mapping(uint128 => uint) daily;\n    mapping(uint128 => uint) weekly;\n}\n"
    },
    "contracts/nft/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/introspection/IERC165.sol';\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { IERC1155Metadata } from './IERC1155Metadata.sol';\nimport { ERC1155MetadataInternal } from './ERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @notice ERC1155 metadata extensions\n */\nabstract contract ERC1155Metadata is IERC1155Metadata, ERC1155MetadataInternal {\n    using UintUtils for uint256;\n\n    /**\n     * @notice inheritdoc IERC1155Metadata\n     */\n    function uri(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage\n            .layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary UintUtils {\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @notice ERC1155Metadata internal functions\n */\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\n    /**\n     * @notice set base metadata URI\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\n     * @param baseURI base URI\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    /**\n     * @notice set per-token metadata URI\n     * @param tokenId token whose metadata URI to set\n     * @param tokenURI per-token URI\n     */\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @notice ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "contracts/agent/facets/PrimaryMarketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport '../../shared/lib/LibPausable.sol';\nimport '../../shared/lib/Util.sol';\nimport '../lib/pricing/LibPricingStatic.sol';\nimport '../lib/pricing/LibPricingLinearDecay.sol';\n\n/**\n * @title PrimaryMarketFacet\n * @author Shu Dong\n * @notice Facet contract holding functions for primary market sale\n */\ncontract PrimaryMarketFacet is PausableModifier, PricingStatic, PricingLinearDecay {\n    AppStorage internal s;\n\n    using SafeERC20 for IERC20;\n\n    event Claim(address indexed, address indexed, uint[], uint[]);\n    event IncreaseAllowance(\n        address indexed,\n        address indexed,\n        uint[],\n        uint[]\n    );\n    event DecreaseAllowance(\n        address indexed,\n        address indexed,\n        uint[],\n        uint[]\n    );\n\n    struct ClaimState {\n        uint billing;\n        uint tokenCost;\n        uint totalCost;\n        uint totalPay;\n    }\n\n    /**\n     * @notice set pricing strategy for msg.sender\n     * @param strategy pricing strategy to set, currently STATIC and LINEAR_DECAY are supported\n     * @param args Arguments of pricing strategy set\n     */\n    function setPricingStrategy(\n        PricingStorage.PricingStrategy strategy,\n        bytes memory args\n    ) external {\n        PricingStorage.Layout storage l = PricingStorage.layout();\n        l.strategy[msg.sender] = strategy;\n        if (strategy == PricingStorage.PricingStrategy.STATIC) {\n            LibPricingStatic.initialize(l, msg.sender, args);\n        } else if (strategy == PricingStorage.PricingStrategy.LINEAR_DECAY) {\n            LibPricingLinearDecay.initialize(l, msg.sender, args);\n        }\n    }\n\n    /**\n     * @notice increase allowance of target for msg.sender\n     * @param target Address of target user\n     * @param ids DeMine nft token ids to increase allowance\n     * @param amounts Amount to increase per token\n     */\n    function increaseAllowance(\n        address target,\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) external whenNotPaused {\n        require(\n            ids.length == amounts.length,\n            \"PoolOwnerFacet: array length mismatch\"\n        );\n        for (uint i = 0; i < ids.length; i++) {\n            s.allowances[target][target][ids[i]] += amounts[i];\n        }\n        emit IncreaseAllowance(msg.sender, target, ids, amounts);\n    }\n\n    /**\n     * @notice decrease allowance of target for msg.sender\n     * @param target Address of target user\n     * @param ids DeMine nft token ids to decrease allowance\n     * @param amounts Amount to decrease per token\n     */\n    function decreaseAllowance(\n        address target,\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) external whenNotPaused {\n        require(\n            ids.length == amounts.length,\n            \"DeMineNFTMetadata: array length mismatch\"\n        );\n        for (uint i = 0; i < ids.length; i++) {\n            uint allowance = s.allowances[msg.sender][target][ids[i]];\n            require(\n                allowance >= amounts[i],\n                \"DeMineAgent: allowance will below zero\"\n            );\n            s.allowances[msg.sender][target][ids[i]] = allowance - amounts[i];\n        }\n        emit DecreaseAllowance(msg.sender, target, ids, amounts);\n    }\n\n    /**\n     * @notice claim tokens listed for msg.sender from DeMineAgent\n     * @param from Address of demine nft issuer\n     * @param ids DeMine nft token ids to buy\n     * @param maxAmounts The max amount to buy per token, the amount of\n     *        final bought token could be less than this per allowance\n     *        and balance state\n     */\n    function claim(\n        address from,\n        uint[] calldata ids,\n        uint[] calldata maxAmounts\n    ) external whenNotPaused returns(uint[] memory) {\n        require(\n            ids.length == maxAmounts.length,\n            \"TokenLocker: array length mismatch\"\n        );\n        ClaimState memory cs = ClaimState(s.billing, s.tokenCost, 0, 0);\n        PricingStorage.Layout storage l = PricingStorage.layout();\n        function(\n            PricingStorage.Layout storage, address, uint, uint\n        ) internal view returns(uint) f = priceF(l.strategy[from]);\n        uint[] memory amounts = new uint[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            require(ids[i] > cs.billing, 'DeMineAgent: billing token');\n            uint amount = maxAllowed(from, ids[i], maxAmounts[i]);\n            amounts[i] = amount;\n            cs.totalCost += cs.tokenCost * amount;\n            cs.totalPay += f(l, from, ids[i], cs.tokenCost) * amount;\n        }\n        s.payment.safeTransferFrom(msg.sender, s.payee, cs.totalCost);\n        s.payment.safeTransferFrom(msg.sender, from, cs.totalPay - cs.totalCost);\n        s.nft.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n        emit Claim(msg.sender, from, ids, amounts);\n        return amounts;\n    }\n\n    /**\n     * @notice get listed prices of demine nft\n     * @param from Address of demine nft issuer\n     * @param ids DeMine nft token ids to check\n     * @return list of prices for each token\n     */\n    function getListedPrices(\n        address from,\n        uint[] calldata ids\n    ) external view returns(uint[] memory) {\n        PricingStorage.Layout storage l = PricingStorage.layout();\n        function(\n            PricingStorage.Layout storage,\n            address,\n            uint,\n            uint\n        ) internal view returns(uint) f = priceF(l.strategy[from]);\n        uint tokenCost = s.tokenCost;\n        uint[] memory prices = new uint[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            prices[i] = f(l, from, ids[i], tokenCost);\n        }\n        return prices;\n    }\n\n    /**\n     * @notice get allowance information\n     * @param from Address of demine nft issuer\n     * @param target Address of target address\n     * @param ids DeMine nft token ids to check\n     */\n    function getAllowances(\n        address from,\n        address target,\n        uint[] calldata ids\n    ) external view returns(uint[] memory) {\n        uint[] memory result = new uint[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            result[i] = s.allowances[from][target][ids[i]];\n        }\n        return result;\n    }\n\n    function maxAllowed(address from, uint id, uint amount) private returns(uint) {\n        uint balance = s.balances[id][from];\n        amount = Util.min2(balance, amount);\n        amount = checkAllowance(from, id, amount);\n        s.balances[id][from] = balance - amount;\n        return amount;\n    }\n\n    function checkAllowance(address from, uint id, uint amount) private returns(uint) {\n        uint allowance1 = s.allowances[from][msg.sender][id];\n        uint allowance2 = s.allowances[from][address(0)][id];\n        uint allowed = allowance1 + allowance2;\n        if (amount <= allowance1) {\n            s.allowances[from][msg.sender][id] -= amount;\n            return amount;\n        } else if (amount <= allowed) {\n            s.allowances[from][msg.sender][id] = 0;\n            s.allowances[from][address(0)][id] = amount - allowance1;\n            return amount;\n        } else {\n            s.allowances[from][msg.sender][id] = 0;\n            s.allowances[from][address(0)][id] = 0;\n            return allowed;\n        }\n    }\n\n    function priceF(\n        PricingStorage.PricingStrategy strategy\n    ) private pure returns(\n        function(\n            PricingStorage.Layout storage, address, uint, uint\n        ) internal view returns(uint) f\n    ) {\n        if (strategy == PricingStorage.PricingStrategy.STATIC) {\n            f = LibPricingStatic.priceOf;\n        } else if (strategy == PricingStorage.PricingStrategy.LINEAR_DECAY) {\n            f = LibPricingLinearDecay.priceOf;\n        }\n    }\n}\n"
    },
    "contracts/agent/lib/pricing/LibPricingStatic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '../../../shared/lib/Util.sol';\nimport '../AppStorage.sol';\nimport './PricingStorage.sol';\n\nlibrary LibPricingStatic {\n    function priceOf(\n        PricingStorage.Layout storage l,\n        address account,\n        uint id,\n        uint tokenCost\n    ) internal view returns(uint) {\n        uint tokenPrice = l.staticOverride[account][id];\n        return Util.max2(\n            tokenPrice > 0 ? tokenPrice : l.staticBase[account],\n            tokenCost\n        );\n    }\n\n    function initialize(\n        PricingStorage.Layout storage l,\n        address from,\n        bytes memory args\n    ) internal {\n        (\n            uint basePrice,\n            uint[] memory ids,\n            uint[] memory prices\n        ) = abi.decode(args, (uint, uint[], uint[]));\n        l.staticBase[from] = basePrice;\n        setOverride(l, from, ids, prices);\n    }\n\n    function setOverride(\n        PricingStorage.Layout storage l,\n        address from,\n        uint[] memory ids,\n        uint[] memory prices\n    ) internal {\n        require(\n            ids.length == prices.length,\n            \"LibPricingStatic: base price is lower than token cost\"\n        );\n        for (uint i = 0; i < ids.length; i++) {\n            l.staticOverride[from][ids[i]] = prices[i];\n        }\n    }\n}\n\nabstract contract PricingStatic {\n    using LibPricingStatic for PricingStorage.Layout;\n\n    event SetStaticBase(address indexed, uint);\n    event SetStaticOverride(address indexed, uint[], uint[]);\n\n    function setStaticBase(uint price) external {\n        PricingStorage.layout().staticBase[msg.sender] = price;\n        emit SetStaticBase(msg.sender, price);\n    }\n\n    function setStaticOverride(\n        uint[] memory ids,\n        uint[] memory prices\n    ) external {\n        PricingStorage.layout().setOverride(msg.sender, ids, prices);\n        emit SetStaticOverride(msg.sender, ids, prices);\n    }\n}\n"
    },
    "contracts/agent/lib/pricing/LibPricingLinearDecay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '../../../shared/lib/Util.sol';\nimport '../AppStorage.sol';\nimport './PricingStorage.sol';\n\nlibrary LibPricingLinearDecay {\n    function priceOf(\n        PricingStorage.Layout storage l,\n        address account,\n        uint id,\n        uint tokenCost\n    ) internal view returns(uint) {\n        PricingStorage.LinearDecay memory ld = l.linearDecay[account];\n        if (id < ld.anchor) {\n            return ld.maxPrice;\n        }\n        uint price = ld.maxPrice - (id - ld.anchor) * ld.slope / ld.slopeBase;\n        return Util.max3(price, ld.minPrice, tokenCost);\n    }\n\n    function initialize(\n        PricingStorage.Layout storage l,\n        address from,\n        bytes memory args\n    ) internal {\n        PricingStorage.LinearDecay memory ld\n            = abi.decode(args, (PricingStorage.LinearDecay));\n        l.linearDecay[from] = ld;\n    }\n}\n\nabstract contract PricingLinearDecay {\n    using LibPricingLinearDecay for PricingStorage.Layout;\n\n    event SetLinerPricing(\n        address indexed,\n        uint,\n        uint128,\n        uint128,\n        uint,\n        uint\n    );\n\n    function setLinearDecay(\n        PricingStorage.LinearDecay memory ld\n    ) external {\n        PricingStorage.layout().linearDecay[msg.sender] = ld;\n        emit SetLinerPricing(\n            msg.sender,\n            ld.anchor,\n            ld.slope,\n            ld.slopeBase,\n            ld.maxPrice,\n            ld.minPrice\n        );\n    }\n}\n"
    },
    "contracts/agent/lib/pricing/PricingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary PricingStorage {\n    enum PricingStrategy{ STATIC, LINEAR_DECAY }\n\n    struct LinearDecay {\n        uint anchor;\n        uint128 slope;\n        uint128 slopeBase;\n        uint maxPrice;\n        uint minPrice;\n    }\n\n    struct Layout {\n        mapping(address => PricingStrategy) strategy;\n        // static pricing\n        mapping(address => uint) staticBase;\n        mapping(address => mapping(uint => uint)) staticOverride;\n        // linear decay\n        mapping(address => LinearDecay) linearDecay;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.agent.contracts.storage.Pricing');\n\n    function layout() internal pure returns(Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/shared/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/access/SafeOwnable.sol';\nimport '@solidstate/contracts/access/IERC173.sol';\nimport '@solidstate/contracts/introspection/IERC165.sol';\nimport '@solidstate/contracts/introspection/ERC165Storage.sol';\nimport '@solidstate/contracts/proxy/diamond/DiamondBase.sol';\nimport '@solidstate/contracts/proxy/diamond/DiamondCuttable.sol';\nimport '@solidstate/contracts/proxy/diamond/DiamondLoupe.sol';\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport './lib/LibInitializable.sol';\nimport './lib/LibPausable.sol';\n\ncontract Diamond is\n    IERC165,\n    Initializable,\n    Pausable,\n    SafeOwnable,\n    DiamondBase,\n    DiamondCuttable,\n    DiamondLoupe\n{\n    using ERC165Storage for ERC165Storage.Layout;\n    using OwnableStorage for OwnableStorage.Layout;\n\n    event Clone(address indexed from, address indexed cloned);\n\n    struct InitArgs {\n        address owner;\n        bytes4[] selectors;\n        bytes32[] facetsSlotPosition;\n        bytes32[] selectorSlots;\n        address fallbackAddress;\n        bytes fallbackInitArgs;\n        bytes4[] interfaces;\n    }\n\n    function init(InitArgs calldata args) external initializer {\n        OwnableStorage.layout().setOwner(args.owner);\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        l.fallbackAddress = args.fallbackAddress;\n        (bool success, bytes memory result) = args.fallbackAddress.delegatecall(\n            abi.encodeWithSignature(\n                \"__DiamondFallback_init(bytes)\",\n                args.fallbackInitArgs\n            )\n        );\n        require(success, string(result));\n\n        l.selectorCount = uint16(args.selectors.length);\n        for (uint i; i < args.selectors.length; i++) {\n            l.facets[args.selectors[i]] = args.facetsSlotPosition[i];\n        }\n        for (uint i; i < args.selectorSlots.length; i++) {\n            l.selectorSlots[i] = args.selectorSlots[i];\n       }\n\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\n        for (uint i; i < args.interfaces.length; i++) {\n            erc165.setSupportedInterface(args.interfaces[i], true);\n        }\n    }\n\n    function create(InitArgs memory args) external {\n        address cloned = Clones.clone(address(this));\n        Diamond(payable(cloned)).init(args);\n        emit Clone(address(this), cloned);\n    }\n\n    function getFallbackAddress() external view returns (address) {\n        return DiamondBaseStorage.layout().fallbackAddress;\n    }\n\n    function setFallbackAddress(address fallbackAddress) external {\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\n    }\n\n    function setSupportedInterface(bytes4 interfaceId, bool supported) external {\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\n        erc165.setSupportedInterface(interfaceId, supported);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public virtual override view returns (bool) {\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\n        return interfaceId == type(IPausable).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IDiamondCuttable).interfaceId ||\n            interfaceId == type(IDiamondLoupe).interfaceId ||\n            erc165.isSupportedInterface(interfaceId);\n    }\n\n    receive() external payable { }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    function nomineeOwner() public view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @inheritdoc Ownable\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n}\n"
    },
    "@solidstate/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@solidstate/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from './IERC173.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IERC173, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual override returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal {\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        require(\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\n            'SafeOwnable: sender must be nominee owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}