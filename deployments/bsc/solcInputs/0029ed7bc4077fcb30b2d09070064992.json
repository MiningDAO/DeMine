{
  "language": "Solidity",
  "sources": {
    "contracts/nft/facets/ERC1155Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/introspection/ERC165.sol';\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\nimport '@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol';\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport '../../shared/lib/DiamondFallback.sol';\nimport '../../shared/lib/LibPausable.sol';\nimport './MiningOracle.sol';\nimport './ERC1155Config.sol';\n\ncontract ERC1155Facet is\n    DiamondFallback,\n    ERC1155Base,\n    MiningOracle,\n    ERC1155Config,\n    ERC165\n{\n    using SafeERC20 for IERC20;\n\n    event Alchemy(address indexed account, uint totalEarning);\n\n    function init(bytes memory args) internal override onlyInitializing {\n        (\n            address recipient,\n            uint16 bps,\n            address earningTokenAdd,\n            string memory uri\n        ) = abi.decode(args, (address, uint16, address, string));\n        s.royalty = RoyaltyInfo(recipient, bps);\n        s.earningToken = IERC20(earningTokenAdd);\n        _setBaseURI(uri);\n    }\n\n    function mintBatch(\n        address account,\n        uint[] calldata ids,\n        uint[] calldata amounts,\n        bytes memory data\n    ) external onlyOwner {\n        _safeMintBatch(account, ids, amounts, data);\n    }\n\n    function burnBatch(\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) external onlyOwner {\n        _burnBatch(msg.sender, ids, amounts);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint[] memory ids,\n        uint[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155BaseInternal) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n        address alchemist = _alchemist();\n        require(from != alchemist, 'DeMineNFT: from alchemist');\n        // alchemize\n        if (to == alchemist) {\n            require(!LibPausable.layout().paused, 'Pausable: paused');\n            uint totalEarning;\n            uint finalized = s.finalized;\n            for (uint i; i < ids.length; i++) {\n                (uint128 start, uint128 end) = decode(ids[i]);\n                require(end <= finalized, 'DeMineNFT: token not finalized yet');\n                totalEarning += amounts[i] * _earning(start, end);\n            }\n            s.earningToken.safeTransfer(from, totalEarning);\n            emit Alchemy(from, totalEarning);\n        }\n    }\n\n    function decode(uint tokenId) private pure returns(uint128, uint128) {\n        return (uint128(tokenId >> 128), uint128(tokenId));\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from './IERC165.sol';\nimport { ERC165Storage } from './ERC165Storage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n    using ERC165Storage for ERC165Storage.Layout;\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155Internal } from './IERC1155Internal.sol';\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155 } from '../IERC1155.sol';\nimport { IERC1155Receiver } from '../IERC1155Receiver.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from './ERC1155BaseInternal.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155, ERC1155BaseInternal {\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balanceOf(account, id);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            'ERC1155: accounts and ids length mismatch'\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; i++) {\n                require(\n                    accounts[i] != address(0),\n                    'ERC1155: batch balance query for the zero address'\n                );\n                batchBalances[i] = balances[ids[i]][accounts[i]];\n            }\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function setApprovalForAll(address operator, bool status)\n        public\n        virtual\n        override\n    {\n        require(\n            msg.sender != operator,\n            'ERC1155: setting approval status for self'\n        );\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: caller is not owner nor approved'\n        );\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: caller is not owner nor approved'\n        );\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/shared/lib/DiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport './LibInitializable.sol';\n\nabstract contract DiamondFallback is Initializable {\n    function init(bytes memory args) internal virtual;\n\n    function __DiamondFallback_init(bytes memory args) external onlyInitializing {\n        init(args);\n    }\n}\n"
    },
    "contracts/shared/lib/LibPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport '../interfaces/IPausable.sol';\n\nlibrary LibPausable {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract PausableModifier {\n    modifier whenPaused() {\n        require(LibPausable.layout().paused, 'Pausable: not paused');\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!LibPausable.layout().paused, 'Pausable: paused');\n        _;\n    }\n}\n\nabstract contract Pausable is IPausable, OwnableInternal {\n    function paused() external override view returns (bool) {\n        return LibPausable.layout().paused;\n    }\n\n    function pause() external onlyOwner override {\n        LibPausable.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyOwner override {\n        LibPausable.layout().paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "contracts/nft/facets/MiningOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport './Base.sol';\n\nabstract contract MiningOracle is Base {\n    event Finalize(uint128 indexed, uint);\n\n    function finalize(uint128 timestamp, uint earningPerToken) external onlyOwner {\n        require(\n            timestamp > s.finalized && timestamp % 86400 == 0,\n            'DeMineNFT: invalid timestamp'\n        );\n        s.finalized = timestamp;\n        s.daily[timestamp] = earningPerToken;\n        for(uint128 i = 0; i < 7; i++) {\n            s.weekly[timestamp + i * 86400] += earningPerToken;\n        }\n        emit Finalize(timestamp, earningPerToken);\n    }\n\n    function finalized() external view returns(uint128) {\n        return s.finalized;\n    }\n\n    function earning(uint tokenId) external view returns(uint) {\n        uint128 start = uint128(tokenId >> 128);\n        uint128 end = uint128(tokenId);\n        return _earning(start, end);\n    }\n\n    function _earning(uint128 start, uint128 end)\n        internal\n        view\n        returns(uint value)\n    {\n        // daily token\n        if (end - start == 86400) {\n            value = s.daily[end];\n        // weekly token\n        } else if (end - start == 604800) {\n            value = s.weekly[end];\n        // biweekly token\n        } else if (end - start == 1209600) {\n            value = s.weekly[end] + s.weekly[end - 604800];\n        }\n    }\n}\n"
    },
    "contracts/nft/facets/ERC1155Config.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/IERC2981.sol';\nimport '../interfaces/IERC1155Rewardable.sol';\nimport './Base.sol';\nimport '@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol';\n\nabstract contract ERC1155Config is\n    Base,\n    IERC2981,\n    IERC1155Rewardable,\n    ERC1155Metadata\n{\n    event TokenRoyaltyBpsSet(uint16);\n\n    function setURI(string memory baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n    }\n\n    function setRoyaltyInfo(address recipient, uint16 bps) external onlyOwner {\n        s.royalty = RoyaltyInfo(recipient, bps);\n        emit TokenRoyaltyBpsSet(bps);\n    }\n\n    function royaltyInfo(uint256, uint256 value)\n        external\n        view\n        override\n        returns (address, uint256)\n    {\n        RoyaltyInfo memory r = s.royalty;\n        return (r.recipient, (value * r.bps) / 10000);\n    }\n\n    function earningToken() external override view returns(address) {\n        return address(s.earningToken);\n    }\n\n    function alchemist() external override pure returns(address) {\n        return _alchemist();\n    }\n\n    function _alchemist() internal pure returns(address) {\n        return address(0x1A811678eEEDF16a1D0dF4b12e290F78a61A28F9);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC1155Internal } from '../IERC1155Internal.sol';\nimport { IERC1155Receiver } from '../IERC1155Receiver.sol';\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155Internal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            'ERC1155: balance query for the zero address'\n        );\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: mint to the zero address');\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n        balances[account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: mint to the zero address');\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; i++) {\n            balances[ids[i]][account] += amounts[i];\n        }\n\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _safeMintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _mintBatch(account, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice burn given quantity of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param id token ID\n     * @param amount quantity of tokens to burn\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: burn from the zero address');\n\n        _beforeTokenTransfer(\n            msg.sender,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            ''\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n\n        unchecked {\n            require(\n                balances[account] >= amount,\n                'ERC1155: burn amount exceeds balances'\n            );\n            balances[account] -= amount;\n        }\n\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\n    }\n\n    /**\n     * @notice burn given batch of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param ids token IDs\n     * @param amounts quantities of tokens to burn\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), 'ERC1155: burn from the zero address');\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            for (uint256 i; i < ids.length; i++) {\n                uint256 id = ids[i];\n                require(\n                    balances[id][account] >= amounts[i],\n                    'ERC1155: burn amount exceeds balance'\n                );\n                balances[id][account] -= amounts[i];\n            }\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(\n            recipient != address(0),\n            'ERC1155: transfer to the zero address'\n        );\n\n        _beforeTokenTransfer(\n            operator,\n            sender,\n            recipient,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            require(\n                senderBalance >= amount,\n                'ERC1155: insufficient balances for transfer'\n            );\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(\n            recipient != address(0),\n            'ERC1155: transfer to the zero address'\n        );\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; i++) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n                require(\n                    senderBalance >= amount,\n                    'ERC1155: insufficient balances for transfer'\n                );\n                balances[token][sender] = senderBalance - amount;\n            }\n\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(uint256 element)\n        private\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                require(\n                    response == IERC1155Receiver.onERC1155Received.selector,\n                    'ERC1155: ERC1155Receiver rejected tokens'\n                );\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert('ERC1155: transfer to non ERC1155Receiver implementer');\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                require(\n                    response ==\n                        IERC1155Receiver.onERC1155BatchReceived.selector,\n                    'ERC1155: ERC1155Receiver rejected tokens'\n                );\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert('ERC1155: transfer to non ERC1155Receiver implementer');\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 => mapping(address => uint256)) balances;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/shared/lib/LibInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/utils/AddressUtils.sol';\n\n/**\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary InitializableStorage {\n    struct Layout {\n        bool initialized;\n        bool initializing;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.contracts.storage.Initializable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract Initializable {\n    modifier initializer() {\n        InitializableStorage.Layout storage l = InitializableStorage.layout();\n        require(\n            l.initializing ? isConstructor() : !l.initialized,\n            'Initializable: contract is already initialized'\n        );\n        bool isTopLevelCall = !l.initializing;\n        if (isTopLevelCall) {\n            l.initializing = true;\n            l.initialized = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            l.initializing = false;\n        }\n    }\n\n    modifier onlyInitializing() {\n        require(\n            InitializableStorage.layout().initializing,\n            'Initializable: contract is not initializing'\n        );\n        _;\n    }\n\n    function isConstructor() private view returns (bool) {\n        return !AddressUtils.isContract(address(this));\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "contracts/shared/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IPausable {\n    /**\n     * @dev Emitted when paused by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when unpaused by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Should return if the contract is paused\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @dev pause the contract\n     */\n    function pause() external;\n\n    /**\n     * @dev unpause the contract\n     */\n    function unpause() external;\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "contracts/nft/facets/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\n\nimport '../lib/AppStorage.sol';\n\nabstract contract Base is OwnableInternal {\n    AppStorage internal s;\n}\n"
    },
    "contracts/nft/lib/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nstruct RoyaltyInfo {\n    address recipient;\n    uint16 bps;\n}\n\nstruct AppStorage {\n    IERC20 earningToken;\n    RoyaltyInfo royalty;\n\n    // Oracle\n    uint128 finalized;\n    mapping(uint128 => uint) daily;\n    mapping(uint128 => uint) weekly;\n}\n"
    },
    "contracts/nft/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/introspection/IERC165.sol';\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "contracts/nft/interfaces/IERC1155Rewardable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\n\ninterface IERC1155Rewardable is IERC1155 {\n    function alchemist() external view returns(address);\n\n    function earningToken() external view returns(address);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { IERC1155Metadata } from './IERC1155Metadata.sol';\nimport { ERC1155MetadataInternal } from './ERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @notice ERC1155 metadata extensions\n */\nabstract contract ERC1155Metadata is IERC1155Metadata, ERC1155MetadataInternal {\n    using UintUtils for uint256;\n\n    /**\n     * @notice inheritdoc IERC1155Metadata\n     */\n    function uri(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage\n            .layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary UintUtils {\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @notice ERC1155Metadata internal functions\n */\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\n    /**\n     * @notice set base metadata URI\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\n     * @param baseURI base URI\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    /**\n     * @notice set per-token metadata URI\n     * @param tokenId token whose metadata URI to set\n     * @param tokenURI per-token URI\n     */\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @notice ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}