{
  "language": "Solidity",
  "sources": {
    "contracts/agent/DeMineAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/proxy/diamond/IDiamondCuttable.sol';\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport '@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol';\n\nimport '../shared/lib/DeMineBase.sol';\nimport '../nft/interfaces/IMiningPool.sol';\nimport './lib/AppStorage.sol';\n\ncontract DeMineAgent is DeMineBase {\n    AppStorage internal s;\n\n    function initialize(\n        address diamondFacet,\n        address mortgageFacet,\n        IDiamondCuttable.FacetCut[] calldata facetCuts,\n        address nft,\n        address payment,\n        address payee,\n        uint256 tokenCost\n    ) external initializer {\n        __DeMineBase_init(diamondFacet, mortgageFacet, facetCuts);\n        s.nft = nft;\n        s.income = IERC20(IMiningPool(nft).treasureSource());\n        s.payment = IERC20(payment);\n        s.payee = payee;\n        s.tokenCost = tokenCost;\n    }\n\n    function create(\n        address diamondFacet,\n        address mortgageFacet,\n        IDiamondCuttable.FacetCut[] calldata facetCuts,\n        address nft,\n        address payment,\n        address payee,\n        uint256 tokenCost\n    ) external {\n        address cloned = Clones.clone(address(this));\n        DeMineAgent(payable(cloned)).initialize(\n            diamondFacet, mortgageFacet, facetCuts, nft, payment, payee, tokenCost\n        );\n        emit Clone(address(this), cloned);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public override(DeMineBase) view returns (bool) {\n        return super.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC1155Receiver).interfaceId;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/IDiamondCuttable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Diamond proxy upgrade interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondCuttable {\n    enum FacetCutAction {\n        ADD,\n        REPLACE,\n        REMOVE\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\n\n    struct FacetCut {\n        address target;\n        FacetCutAction action;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice update diamond facets and optionally execute arbitrary initialization function\n     * @param facetCuts facet addresses, actions, and function selectors\n     * @param target initialization function target\n     * @param data initialization function call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/shared/lib/DeMineBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/access/SafeOwnable.sol';\nimport '@solidstate/contracts/access/SafeOwnable.sol';\nimport '@solidstate/contracts/access/IERC173.sol';\nimport '@solidstate/contracts/introspection/IERC165.sol';\nimport '@solidstate/contracts/proxy/diamond/DiamondBase.sol';\n\nimport '../facets/DiamondFacet.sol';\nimport './LibInitializable.sol';\nimport './LibPausable.sol';\n\nabstract contract DeMineBase is\n    IERC165,\n    DiamondBase,\n    Initializable,\n    Pausable,\n    SafeOwnable\n{\n    event Clone(address indexed from, address indexed cloned);\n\n    using OwnableStorage for OwnableStorage.Layout;\n\n    function __DeMineBase_init(\n        address diamondFacet,\n        address fallbackAddress,\n        IDiamondCuttable.FacetCut[] calldata facetCuts\n    ) internal onlyInitializing {\n        OwnableStorage.layout().setOwner(msg.sender);\n        (bool success, bytes memory returndata) = diamondFacet.delegatecall(\n            abi.encodeWithSelector(\n                IDiamondCuttable.diamondCut.selector,\n                facetCuts,\n                address(0),\n                \"\"\n            )\n        );\n        require(success, string(returndata));\n        // set fallback address\n        (success, returndata) = diamondFacet.delegatecall(\n            abi.encodeWithSelector(\n                DiamondFacet.setFallbackAddress.selector,\n                fallbackAddress\n            )\n        );\n        require(success, string(returndata));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public virtual override view returns (bool) {\n        return interfaceId == type(IPausable).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IDiamondCuttable).interfaceId ||\n            interfaceId == type(IDiamondLoupe).interfaceId;\n    }\n\n    receive() external payable { }\n}\n"
    },
    "contracts/nft/interfaces/IMiningPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/token/ERC1155/IERC1155Internal.sol';\n\n/**\n * @dev Interface for DeMineNFT for DeMineAgent\n */\ninterface IMiningPool is IERC1155Internal {\n    /**\n     * @dev shrink mining pool by burning token not mined\n     * @param ids List of token ids to burn\n     */\n    function shrink(uint[] memory ids) external;\n\n    /**\n     * @dev burn tokens in batch and cashout income\n     * @param ids List of token ids to alchemize\n     * @return total income\n     */\n    function alchemize(uint[] memory ids) external returns(uint);\n\n    function getMining() external view returns(uint);\n\n    function treasureSource() external view returns(address);\n}\n"
    },
    "contracts/agent/lib/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct Account {\n    uint start; // starting from 2**256 - 1 - start\n    uint end;\n    uint maxBalance;\n}\n\nstruct Statement {\n    uint balance;\n    uint income;\n    uint debt;\n}\n\nstruct AppStorage {\n    uint tokenCost; // cost per nft in cost token\n\n    IERC20 income;\n    IERC20 payment;\n    address nft; // DeMineNFT contract address\n    address payee; // payee account address, could be contract\n\n    bool initialized;\n    uint8 depositMultiplier; // deposit = maxBalance * tokenCost * depositMultiplier\n    uint deposit; // total deposit in cost token\n    uint billing; // current billing token\n    // billing statement\n    mapping(uint => Statement) statements;\n    // account info\n    mapping(address => Account) accounts;\n    // tokenId => account => price\n    mapping(uint => mapping(address => uint)) balances;\n    // owner => buyer => allowance\n    mapping(address => mapping(address => mapping(uint => uint))) allowances;\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    function nomineeOwner() public view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @inheritdoc Ownable\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n}\n"
    },
    "@solidstate/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Proxy } from '../Proxy.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\nimport { IDiamondLoupe } from './IDiamondLoupe.sol';\nimport { IDiamondCuttable } from './IDiamondCuttable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy base contract\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\nabstract contract DiamondBase is Proxy {\n    /**\n     * @inheritdoc Proxy\n     */\n    function _getImplementation() internal view override returns (address) {\n        // inline storage layout retrieval uses less gas\n        DiamondBaseStorage.Layout storage l;\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n\n        address implementation = address(bytes20(l.facets[msg.sig]));\n\n        if (implementation == address(0)) {\n            implementation = l.fallbackAddress;\n            require(\n                implementation != address(0),\n                'DiamondBase: no facet found for function signature'\n            );\n        }\n\n        return implementation;\n    }\n}\n"
    },
    "contracts/shared/facets/DiamondFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/proxy/diamond/DiamondCuttable.sol';\nimport '@solidstate/contracts/proxy/diamond/DiamondLoupe.sol';\n\ncontract DiamondFacet is DiamondCuttable, DiamondLoupe {\n    function getFallbackAddress() external view returns (address) {\n        return DiamondBaseStorage.layout().fallbackAddress;\n    }\n\n    function setFallbackAddress(address fallbackAddress) external {\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\n    }\n}\n"
    },
    "contracts/shared/lib/LibInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/utils/AddressUtils.sol';\n\n/**\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary InitializableStorage {\n    struct Layout {\n        bool initialized;\n        bool initializing;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.contracts.storage.Initializable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract Initializable {\n    modifier initializer() {\n        InitializableStorage.Layout storage l = InitializableStorage.layout();\n        require(\n            l.initializing ? isConstructor() : !l.initialized,\n            'Initializable: contract is already initialized'\n        );\n        bool isTopLevelCall = !l.initializing;\n        if (isTopLevelCall) {\n            l.initializing = true;\n            l.initialized = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            l.initializing = false;\n        }\n    }\n\n    modifier onlyInitializing() {\n        require(\n            InitializableStorage.layout().initializing,\n            'Initializable: contract is not initializing'\n        );\n        _;\n    }\n\n    function isConstructor() private view returns (bool) {\n        return !AddressUtils.isContract(address(this));\n    }\n}\n"
    },
    "contracts/shared/lib/LibPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport '../interfaces/IPausable.sol';\n\nlibrary LibPausable {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract PausableModifier {\n    modifier whenPaused() {\n        require(LibPausable.layout().paused, 'Pausable: not paused');\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!LibPausable.layout().paused, 'Pausable: paused');\n        _;\n    }\n}\n\nabstract contract Pausable is IPausable, OwnableInternal {\n    function paused() external override view returns (bool) {\n        return LibPausable.layout().paused;\n    }\n\n    function pause() external onlyOwner override {\n        LibPausable.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyOwner override {\n        LibPausable.layout().paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from './IERC173.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IERC173, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual override returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal {\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        require(\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\n            'SafeOwnable: sender must be nominee owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        require(\n            implementation.isContract(),\n            'Proxy: implementation must be contract'\n        );\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IDiamondCuttable } from './IDiamondCuttable.sol';\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    using AddressUtils for address;\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    event DiamondCut(\n        IDiamondCuttable.FacetCut[] facetCuts,\n        address target,\n        bytes data\n    );\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param l storage layout\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function diamondCut(\n        Layout storage l,\n        IDiamondCuttable.FacetCut[] memory facetCuts,\n        address target,\n        bytes memory data\n    ) internal {\n        unchecked {\n            uint256 originalSelectorCount = l.selectorCount;\n            uint256 selectorCount = originalSelectorCount;\n            bytes32 selectorSlot;\n\n            // Check if last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                // get last selectorSlot\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\n            }\n\n            for (uint256 i; i < facetCuts.length; i++) {\n                IDiamondCuttable.FacetCut memory facetCut = facetCuts[i];\n                IDiamondCuttable.FacetCutAction action = facetCut.action;\n\n                require(\n                    facetCut.selectors.length > 0,\n                    'DiamondBase: no selectors specified'\n                );\n\n                if (action == IDiamondCuttable.FacetCutAction.ADD) {\n                    (selectorCount, selectorSlot) = l.addFacetSelectors(\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                } else if (action == IDiamondCuttable.FacetCutAction.REPLACE) {\n                    l.replaceFacetSelectors(facetCut);\n                } else if (action == IDiamondCuttable.FacetCutAction.REMOVE) {\n                    (selectorCount, selectorSlot) = l.removeFacetSelectors(\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                }\n            }\n\n            if (selectorCount != originalSelectorCount) {\n                l.selectorCount = uint16(selectorCount);\n            }\n\n            // If last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\n            }\n\n            emit DiamondCut(facetCuts, target, data);\n            initialize(target, data);\n        }\n    }\n\n    function addFacetSelectors(\n        Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        IDiamondCuttable.FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            require(\n                facetCut.target == address(this) ||\n                    facetCut.target.isContract(),\n                'DiamondBase: ADD target has no code'\n            );\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    'DiamondBase: selector already added'\n                );\n\n                // add facet for selector\n                l.facets[selector] =\n                    bytes20(facetCut.target) |\n                    bytes32(selectorCount);\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\n\n                // clear selector position in slot and add selector\n                selectorSlot =\n                    (selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\n                    selectorSlot = 0;\n                }\n\n                selectorCount++;\n            }\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function removeFacetSelectors(\n        Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        IDiamondCuttable.FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            require(\n                facetCut.target == address(0),\n                'DiamondBase: REMOVE target must be zero address'\n            );\n\n            uint256 selectorSlotCount = selectorCount >> 3;\n            uint256 selectorInSlotIndex = selectorCount & 7;\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                require(\n                    address(bytes20(oldFacet)) != address(0),\n                    'DiamondBase: selector not found'\n                );\n\n                require(\n                    address(bytes20(oldFacet)) != address(this),\n                    'DiamondBase: selector is immutable'\n                );\n\n                if (selectorSlot == 0) {\n                    selectorSlotCount--;\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                // adding a block here prevents stack too deep error\n                {\n                    // replace selector with last selector in l.facets\n                    lastSelector = bytes4(\n                        selectorSlot << (selectorInSlotIndex << 5)\n                    );\n\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        l.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(l.facets[lastSelector]);\n                    }\n\n                    delete l.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = l.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    // update storage with the modified slot\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    selectorSlot =\n                        (selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete l.selectorSlots[selectorSlotCount];\n                    selectorSlot = 0;\n                }\n            }\n\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function replaceFacetSelectors(\n        Layout storage l,\n        IDiamondCuttable.FacetCut memory facetCut\n    ) internal {\n        unchecked {\n            require(\n                facetCut.target.isContract(),\n                'DiamondBase: REPLACE target has no code'\n            );\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                require(\n                    oldFacetAddress != address(0),\n                    'DiamondBase: selector not found'\n                );\n\n                require(\n                    oldFacetAddress != address(this),\n                    'DiamondBase: selector is immutable'\n                );\n\n                require(\n                    oldFacetAddress != facetCut.target,\n                    'DiamondBase: REPLACE target is identical'\n                );\n\n                // replace old facet address\n                l.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(facetCut.target);\n            }\n        }\n    }\n\n    function initialize(address target, bytes memory data) private {\n        require(\n            (target == address(0)) == (data.length == 0),\n            'DiamondBase: invalid initialization parameters'\n        );\n\n        if (target != address(0)) {\n            if (target != address(this)) {\n                require(\n                    target.isContract(),\n                    'DiamondBase: initialization target has no code'\n                );\n            }\n\n            (bool success, ) = target.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondLoupe {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(address facet)\n        external\n        view\n        returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(bytes4 selector)\n        external\n        view\n        returns (address facet);\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondCuttable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableInternal } from '../../access/OwnableInternal.sol';\nimport { IDiamondCuttable } from './IDiamondCuttable.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy update contract\n */\nabstract contract DiamondCuttable is IDiamondCuttable, OwnableInternal {\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external override onlyOwner {\n        DiamondBaseStorage.layout().diamondCut(facetCuts, target, data);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/DiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\nimport { IDiamondLoupe } from './IDiamondLoupe.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy introspection contract\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nabstract contract DiamondLoupe is IDiamondLoupe {\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facets()\n        external\n        view\n        override\n        returns (Facet[] memory diamondFacets)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        diamondFacets = new Facet[](l.selectorCount);\n\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (diamondFacets[facetIndex].target == facet) {\n                        diamondFacets[facetIndex].selectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                diamondFacets[numFacets].target = facet;\n                diamondFacets[numFacets].selectors = new bytes4[](\n                    l.selectorCount\n                );\n                diamondFacets[numFacets].selectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\n\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        // setting the number of facets\n        assembly {\n            mstore(diamondFacets, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facetFunctionSelectors(address facet)\n        external\n        view\n        override\n        returns (bytes4[] memory selectors)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        selectors = new bytes4[](l.selectorCount);\n\n        uint256 numSelectors;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\n                if (facet == address(bytes20(l.facets[selector]))) {\n                    selectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        // set the number of selectors in the array\n        assembly {\n            mstore(selectors, numSelectors)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory addresses)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        addresses = new address[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facet == addresses[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                addresses[numFacets] = facet;\n                numFacets++;\n            }\n        }\n\n        // set the number of facet addresses in the array\n        assembly {\n            mstore(addresses, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondLoupe\n     */\n    function facetAddress(bytes4 selector)\n        external\n        view\n        override\n        returns (address facet)\n    {\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\n    }\n}\n"
    },
    "contracts/shared/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IPausable {\n    /**\n     * @dev Emitted when paused by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when unpaused by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Should return if the contract is paused\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @dev pause the contract\n     */\n    function pause() external;\n\n    /**\n     * @dev unpause the contract\n     */\n    function unpause() external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/nft/DeMineNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/proxy/diamond/IDiamondCuttable.sol';\nimport '@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol';\nimport '@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol';\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport '@solidstate/contracts/introspection/IERC165.sol';\n\nimport '../shared/lib/DeMineBase.sol';\nimport './lib/AppStorage.sol';\nimport './interfaces/IMiningPool.sol';\nimport './interfaces/IERC2981.sol';\n\ncontract DeMineNFT is DeMineBase {\n    AppStorage internal s;\n\n    function initialize(\n        address diamondFacet,\n        address erc1155Facet,\n        IDiamondCuttable.FacetCut[] calldata facetCuts,\n        address income,\n        address recipient,\n        uint16 bps,\n        string memory uri\n    ) external initializer {\n        __DeMineBase_init(diamondFacet, erc1155Facet, facetCuts);\n        ERC1155MetadataStorage.layout().baseURI = uri;\n        s.royalty = RoyaltyInfo(recipient, bps);\n        s.income = IERC20(income);\n    }\n\n    function create(\n        address diamondFacet,\n        address erc1155Facet,\n        IDiamondCuttable.FacetCut[] calldata facetCuts,\n        address income,\n        address recipient,\n        uint16 bps,\n        string memory uri\n    ) external {\n        address cloned = Clones.clone(address(this));\n        DeMineNFT(payable(cloned)).initialize(\n            diamondFacet, erc1155Facet, facetCuts, income, recipient, bps, uri\n        );\n        emit Clone(address(this), cloned);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public override(DeMineBase) view returns (bool) {\n        return super.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155Metadata).interfaceId ||\n            interfaceId == type(IERC2981).interfaceId ||\n            interfaceId == type(IMiningPool).interfaceId;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @notice ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155Internal } from './IERC1155Internal.sol';\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/nft/lib/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nstruct Token {\n    uint supply;\n    uint income;\n}\n\nstruct RoyaltyInfo {\n    address recipient;\n    uint16 bps;\n}\n\nstruct AppStorage {\n    IERC20 income;\n    uint mining;\n    mapping(uint => Token) tokens;\n    RoyaltyInfo royalty;\n}\n"
    },
    "contracts/nft/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/introspection/IERC165.sol';\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}