{
  "language": "Solidity",
  "sources": {
    "contracts/agent/facets/BillingFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport '@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol';\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\n\nimport '../../nft/interfaces/IERC1155Rewardable.sol';\nimport '../../shared/lib/LibPausable.sol';\nimport '../lib/AppStorage.sol';\n\n/**\n * @title BillingFacet\n * @author Shu Dong\n * @notice billing related functions\n */\ncontract BillingFacet is\n    PausableModifier,\n    OwnableInternal,\n    StorageBase\n{\n    using SafeERC20 for IERC20;\n\n    function setBillingMetadata(\n        address chainlink,\n        address swapRouter,\n        uint8 swapRouterVersion,\n        uint16 discount10000Based\n    ) external onlyOwner {\n        s.chainlink = chainlink;\n        s.swapRouter = swapRouter;\n        require(\n            swapRouterVersion == 2 || swapRouterVersion == 3,\n            'Mining3Agent: swap router version not supported'\n        );\n        s.swapRouterVersion = swapRouterVersion;\n        s.earningTokenSaleDiscount10000Based = discount10000Based;\n    }\n\n    /**\n     * @notice It will try to sell earning token at Uniswap\n     * to pay bill and start earning token sale if it fails\n     */\n    function tryBilling(uint tokenId) external onlyOwner {\n        IERC1155Rewardable nft = s.nft;\n        uint balance = nft.balanceOf(address(this), tokenId);\n        if (balance == 0) {\n            return;\n        }\n        uint debt = s.tokenCost * balance;\n        IERC20 earningToken = IERC20(s.nft.earningToken());\n        uint prevBalance = earningToken.balanceOf(address(this));\n        nft.safeTransferFrom(\n            address(this), nft.custodian(), tokenId, balance, ''\n        );\n        uint earning = earningToken.balanceOf(address(this)) - prevBalance;\n        if (earning == 0) {\n            s.statements[tokenId].balance = balance;\n            s.statements[tokenId].debt = debt;\n            return;\n        }\n        (uint earningTokenSold, uint paymentTokenReceived) = trySwap(\n            s.swapRouter,\n            address(earningToken),\n            address(s.paymentToken),\n            earning,\n            debt\n        );\n        if (paymentTokenReceived == debt) {\n            s.statements[tokenId].balance = balance;\n            s.statements[tokenId].surplus = earning - earningTokenSold;\n        } else {\n            s.statements[tokenId] = BillingStatement(\n                balance,\n                earning - earningTokenSold,\n                debt - paymentTokenReceived\n            );\n        }\n    }\n\n    /**\n     * @notice purchase on sale earning token to pay debt for token owner\n     * @param tokenId token id to get statement\n     * @param debtToPay Amount of debt to pay\n     */\n    function purchaseEarningTokenToPayDebt(\n        uint tokenId,\n        uint debtToPay\n    ) external whenNotPaused {\n        BillingStatement memory st = s.statements[tokenId];\n        require(\n            st.surplus > 0 && st.debt > 0,\n            'Mining3Agent: no debt or earning'\n        );\n        if (debtToPay > st.debt) {\n            debtToPay = st.debt;\n        }\n\n        IERC20 earningToken = IERC20(s.nft.earningToken());\n        IERC20 paymentToken = IERC20(s.paymentToken);\n        uint sold = swapTokens(\n            AggregatorV3Interface(s.chainlink),\n            IERC20Metadata(address(earningToken)),\n            IERC20Metadata(address(paymentToken)),\n            debtToPay\n        );\n        // no enough surplus token to pay\n        if (sold > st.surplus) {\n            debtToPay = debtToPay * st.surplus / sold;\n            s.statements[tokenId].surplus = 0;\n            s.statements[tokenId].debt = st.debt - debtToPay;\n        } else {\n            s.statements[tokenId].surplus = st.surplus - sold;\n            s.statements[tokenId].debt = 0;\n        }\n        IERC20(paymentToken).safeTransferFrom(\n            msg.sender, s.custodian, debtToPay\n        );\n        IERC20(earningToken).safeTransfer(msg.sender, sold);\n    }\n\n    function discountInfo(uint value) public view returns(uint) {\n        return value * s.earningTokenSaleDiscount10000Based / 10000;\n    }\n\n    function setDiscountInfo(uint16 discount) external onlyOwner {\n        s.earningTokenSaleDiscount10000Based = discount > 10000 ? 10000 : discount;\n    }\n\n    function swapTokens(\n        AggregatorV3Interface chainlink,\n        IERC20Metadata earningToken,\n        IERC20Metadata paymentToken,\n        uint amountIn // payment token\n    ) private view returns(uint) {\n        (,int price, , ,) = chainlink.latestRoundData();\n        if (price <= 0) { return 0; }\n        uint discountedPrice = discountInfo(uint(price));\n\n        uint8 amountOutDecimals = earningToken.decimals();\n        uint8 amountInDecimals = paymentToken.decimals();\n        uint8 priceDecimals = chainlink.decimals();\n        if (amountOutDecimals + priceDecimals > amountInDecimals) {\n            uint base = 10 ** (amountOutDecimals + priceDecimals - amountInDecimals);\n            return amountIn * base / discountedPrice;\n        } else {\n            uint base = 10 ** (amountInDecimals - amountOutDecimals - priceDecimals);\n            return amountIn / (discountedPrice * base);\n        }\n    }\n\n    function trySwap(\n        address swapRouter,\n        address tokenIn,\n        address tokenOut,\n        uint amountInMax,\n        uint amountOut\n    ) internal returns(uint sold, uint bought) {\n        TransferHelper.safeApprove(tokenIn, swapRouter, amountInMax);\n        uint8 version = s.swapRouterVersion;\n        if (version == 2) {\n            (bool success, bytes memory encoded) = swapRouter.call(\n                abi.encodeWithSignature(\n                    'swapTokensForExactTokens(uint,uint,address[],address,uint)',\n                    amountOut, amountInMax, [tokenIn, tokenOut], address(this), block.timestamp\n                )\n            );\n            if (success) {\n                (sold, bought) = abi.decode(encoded, (uint, uint));\n            }\n        } else if (version == 3) {\n            ISwapRouter.ExactOutputSingleParams memory param =\n            ISwapRouter.ExactOutputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: 3000, // 0.3%\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountOut: amountOut,\n                amountInMaximum: amountInMax,\n                sqrtPriceLimitX96: 0\n            });\n            (bool success, bytes memory encoded) = swapRouter.call(\n                abi.encodeWithSignature(\n                    'exactOutputSingle((address,address,uint24,address,uint,uiint256,uint,uint160))',\n                    param\n                )\n            );\n            if (success) {\n                sold = abi.decode(encoded, (uint));\n                bought = amountOut;\n            }\n        }\n        TransferHelper.safeApprove(tokenIn, swapRouter, 0);\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/nft/interfaces/IERC1155Rewardable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@solidstate/contracts/token/ERC1155/IERC1155.sol';\n\ninterface IERC1155Rewardable is IERC1155 {\n    function custodian() external view returns(address);\n\n    function earningToken() external view returns(address);\n}\n"
    },
    "contracts/shared/lib/LibPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport '../interfaces/IPausable.sol';\n\nlibrary LibPausable {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract PausableModifier {\n    modifier whenPaused() {\n        require(LibPausable.layout().paused, 'Pausable: not paused');\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!LibPausable.layout().paused, 'Pausable: paused');\n        _;\n    }\n}\n\nabstract contract Pausable is IPausable, OwnableInternal {\n    function paused() external override view returns (bool) {\n        return LibPausable.layout().paused;\n    }\n\n    function pause() external onlyOwner override {\n        LibPausable.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyOwner override {\n        LibPausable.layout().paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "contracts/agent/lib/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '../../nft/interfaces/IERC1155Rewardable.sol';\n\nstruct BillingStatement {\n    uint balance;  // Today's total locked (not liquidated) NFT for today\n    uint surplus;  // Today's surplus (mined target tokens - the part to payoff unpaid cost) in incomeToken\n    uint debt;  // The debt in paymentToken if today's mined target tokens cannot pay off cost\n}\n\nstruct AppStorage {\n    uint tokenCost; // cost per nft in payment token\n\n    IERC1155Rewardable nft; // DeMineNFT contract address\n    address paymentToken; // The type of token to pay off cost (e.g. USDT)\n    address custodian; // payee account address, could be contract\n    uint16 royaltyBps;  // royalty bps, 10000 based\n    uint royaltyCap;  // max royalty value to accept\n\n    mapping(uint => mapping(address => uint)) balances;  // owner => buyer => allowance\n\n    // billing related\n    mapping(uint256 => BillingStatement) statements; // Billing statement for each NFT token.\n    address chainlink;\n    address swapRouter;\n    uint8 swapRouterVersion; // 2 or 3 supported\n    uint16 earningTokenSaleDiscount10000Based; // 10000 based\n\n    // primary market sale related\n    // 0: unregistered, 1: pricing strategy, 2: allowance strategy\n    mapping(address => uint8) strategyRegistry;\n    mapping(address => mapping(uint8 => address)) strategies;\n}\n\nabstract contract StorageBase {\n    AppStorage internal s;\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155Internal } from './IERC1155Internal.sol';\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @notice Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IPausable {\n    /**\n     * @dev Emitted when paused by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when unpaused by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Should return if the contract is paused\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @dev pause the contract\n     */\n    function pause() external;\n\n    /**\n     * @dev unpause the contract\n     */\n    function unpause() external;\n}\n"
    },
    "contracts/agent/lib/PricingLinearDecay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport '../../shared/lib/Util.sol';\nimport '../interfaces/IPricingStrategy.sol';\nimport './AppStorage.sol';\nimport './PricingLinearDecayStorage.sol';\n\ncontract PricingLinearDecay is IPricingStrategy {\n    function set(\n        address owner,\n        uint tokenCost,\n        bytes memory args\n    ) external override {\n        PricingLinearDecayStorage.Layout storage l\n            = PricingLinearDecayStorage.layout();\n        PricingLinearDecayStorage.LinearDecay memory ld = abi.decode(\n            args, (PricingLinearDecayStorage.LinearDecay)\n        );\n        require(\n            ld.minPrice >= tokenCost,\n            'PricingLinearDecay: min price smaller token cost'\n        );\n        l.linearDecay[owner] = ld;\n    }\n\n    function priceOfBatch(\n        address owner,\n        uint[] memory ids\n    ) external override view returns(uint[] memory) {\n        uint[] memory prices = new uint[](ids.length);\n        PricingLinearDecayStorage.LinearDecay memory ld\n            = PricingLinearDecayStorage.layout().linearDecay[owner];\n        for (uint i = 0; i < ids.length; i++) {\n            uint128 end = uint128(ids[i]);\n            uint128 start = uint128(ids[i] >> 128);\n            uint128 middle = (end + start) / 2;\n            if (middle < ld.anchor) {\n                prices[i] = ld.maxPrice;\n            } else {\n                uint price = ld.maxPrice - (\n                    middle - ld.anchor\n                ) * ld.slope / ld.slopeBase;\n                prices[i] = Util.max2(price, ld.minPrice);\n            }\n        }\n        return prices;\n    }\n}\n"
    },
    "contracts/shared/lib/Util.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nlibrary Util {\n    function ceil(uint a, uint m) internal pure returns(uint) {\n        return ((a + m - 1) / m) * m;\n    }\n\n    function max3(uint a, uint b, uint c) internal pure returns(uint) {\n        return a > b ? max2(a, c) : max2(b, c);\n    }\n\n    function max2(uint a, uint b) internal pure returns(uint) {\n        return a > b ? a : b;\n    }\n\n    function uint128max2(uint128 a, uint128 b) internal pure returns(uint128) {\n        return a > b ? a : b;\n    }\n\n    function min2(uint a, uint b) internal pure returns(uint) {\n        return a < b ? a : b;\n    }\n\n    function uint128min2(uint128 a, uint128 b) internal pure returns(uint128) {\n        return a < b ? a : b;\n    }\n\n    function min3(uint a, uint b, uint c) internal pure returns(uint) {\n        return a < b ? min2(a, c) : min2(b, c);\n    }\n}\n"
    },
    "contracts/agent/interfaces/IPricingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IPricingStrategy {\n    function set(\n        address owner,\n        uint minPrice,\n        bytes memory args\n    ) external;\n\n    function priceOfBatch(\n        address owner,\n        uint[] memory ids\n    ) external view returns(uint[] memory);\n}\n"
    },
    "contracts/agent/lib/PricingLinearDecayStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nlibrary PricingLinearDecayStorage {\n    struct LinearDecay {\n        uint maxPrice;\n        uint minPrice;\n        uint128 anchor;\n        uint64 slope;\n        uint64 slopeBase;\n    }\n\n    struct Layout {\n        mapping(address => LinearDecay) linearDecay;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('mining3.agent.contracts.storage.PricingLinearDecay');\n\n    function layout() internal pure returns(Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/agent/facets/PrimaryMarketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport '../../shared/lib/LibPausable.sol';\nimport '../lib/AppStorage.sol';\nimport '../interfaces/IPricingStrategy.sol';\nimport '../interfaces/IAllowanceStrategy.sol';\n\n/**\n * @title PrimaryMarketFacet\n * @author Shu Dong\n * @notice Facet contract holding functions for primary market sale\n */\ncontract PrimaryMarketFacet is\n    PausableModifier,\n    OwnableInternal,\n    StorageBase\n{\n    using SafeERC20 for IERC20;\n\n    event Claim(\n        address indexed operator,\n        address indexed from,\n        address indexed to\n    );\n\n    struct ClaimState {\n        uint tokenCost;\n        uint totalCost;\n        uint totalEarned;\n    }\n\n    function batchRegisterStrategies(\n        address[] calldata pricingStrategies,\n        address[] calldata allowanceStrategies\n    ) external onlyOwner {\n        for (uint i = 0; i < pricingStrategies.length; i++) {\n            s.strategyRegistry[pricingStrategies[i]] = 1;\n        }\n        for (uint i = 0; i < allowanceStrategies.length; i++) {\n            s.strategyRegistry[allowanceStrategies[i]] = 2;\n        }\n    }\n\n    function setRoyaltyInfo(\n        uint16 royaltyBps,\n        uint royaltyCap\n    ) external onlyOwner {\n        s.royaltyBps = royaltyBps;\n        s.royaltyCap = royaltyCap;\n    }\n\n    function registerStrategy(\n        address strategy,\n        uint8 strategyType\n    ) external onlyOwner {\n        s.strategyRegistry[strategy] = strategyType;\n    }\n\n    function registeredStrategyType(\n        address strategy\n    ) external view returns(uint8) {\n        return s.strategyRegistry[strategy];\n    }\n\n    function setStrategy(address strategy) external {\n        uint8 strategyType = s.strategyRegistry[strategy];\n        require(\n            strategyType > 0,\n            'Mining3Agent: strategy not registered'\n        );\n        s.strategies[msg.sender][strategyType] = strategy;\n    }\n\n    function getStrategy(uint8 strategyType) external view returns(address) {\n        return s.strategies[msg.sender][strategyType];\n    }\n\n    function setPricing(bytes memory args) external {\n        address pricing = s.strategies[msg.sender][1];\n        require(\n            pricing != address(0),\n            'Mining3Agent: pricing strategy not set'\n        );\n        (\n            bool success,\n            bytes memory result\n        ) = pricing.delegatecall(\n            abi.encodeWithSelector(\n                IPricingStrategy.set.selector,\n                msg.sender,\n                s.tokenCost,\n                args\n            )\n        );\n        require(success, string(result));\n    }\n\n    function setAllowance(address buyer, bytes memory args) external {\n        address allowance = s.strategies[msg.sender][2];\n        require(\n            allowance != address(0),\n            'Mining3Agent: allowance strategy not set'\n        );\n        (\n            bool success,\n            bytes memory result\n        ) = allowance.delegatecall(\n            abi.encodeWithSelector(\n                IAllowanceStrategy.set.selector,\n                msg.sender,\n                buyer,\n                args\n            )\n        );\n        require(success, string(result));\n    }\n\n    function claimFrom(\n        address from,\n        address to,\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) external whenNotPaused returns(uint[] memory) {\n        require(\n            to == msg.sender || to == address(0),\n            'Mining3Agent: invalid operator'\n        );\n        require(\n            ids.length == amounts.length,\n            \"TokenLocker: array length mismatch\"\n        );\n        checkAllowances(from, to, ids, amounts);\n        uint[] memory prices = priceOfBatch(from, ids);\n        ClaimState memory cs = ClaimState(s.tokenCost, 0, 0);\n        for (uint i = 0; i < ids.length; i++) {\n            uint balance = s.balances[ids[i]][from];\n            require(\n                amounts[i] <= balance,\n                'Mining3Agent: insufficient balance'\n            );\n            unchecked {\n                s.balances[ids[i]][from] = balance - amounts[i];\n            }\n            cs.totalCost += cs.tokenCost * amounts[i];\n            cs.totalEarned += (prices[i] - cs.tokenCost) * amounts[i];\n        }\n        IERC20 payment = IERC20(s.paymentToken);\n        uint royalty = royaltyInfo(cs.totalEarned);\n        payment.safeTransferFrom(msg.sender, s.custodian, cs.totalCost + royalty);\n        payment.safeTransferFrom(msg.sender, from, cs.totalEarned - royalty);\n        s.nft.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n        emit Claim(msg.sender, from, to);\n        return amounts;\n    }\n\n    function royaltyInfo(uint totalEarned) public view returns(uint) {\n        uint royalty = (totalEarned * s.royaltyBps) / 10000;\n        uint royaltyCap = s.royaltyCap;\n        return royaltyCap > 0 && royalty > royaltyCap ? royaltyCap : royalty;\n    }\n\n    function priceOfBatch(\n        address account,\n        uint[] calldata ids\n    ) public view returns(uint[] memory prices) {\n        address pricing = s.strategies[account][1];\n        require(pricing != address(0), 'Mining3Agent: pricing not set');\n        (\n            bool success,\n            bytes memory result\n        ) = pricing.staticcall(\n            abi.encodeWithSelector(\n                IPricingStrategy.priceOfBatch.selector,\n                msg.sender,\n                ids\n            )\n        );\n        require(success, string(result));\n        prices = abi.decode(result, (uint[]));\n    }\n\n    function allowanceOfBatch(\n        address owner,\n        address buyer,\n        uint[] calldata ids\n    ) external view returns(uint[] memory allowances) {\n        address allowance = s.strategies[owner][2];\n        require(\n            allowance != address(0),\n            'Mining3Agent: allowance strategy not set'\n        );\n        (\n            bool success,\n            bytes memory result\n        ) = allowance.staticcall(\n            abi.encodeWithSelector(\n                IAllowanceStrategy.allowanceOfBatch.selector,\n                owner,\n                buyer,\n                ids\n            )\n        );\n        require(success, string(result));\n        allowances = abi.decode(result, (uint[]));\n    }\n\n    function checkAllowances(\n        address owner,\n        address buyer,\n        uint[] calldata ids,\n        uint[] calldata amounts\n    ) private {\n        address allowance = s.strategies[owner][2];\n        require(\n            allowance != address(0),\n            'Mining3Agent: allowance strategy not set'\n        );\n        (\n            bool success,\n            bytes memory result\n        ) = allowance.delegatecall(\n            abi.encodeWithSelector(\n                IAllowanceStrategy.checkAllowances.selector,\n                owner,\n                buyer,\n                ids,\n                amounts\n            )\n        );\n        require(success, string(result));\n    }\n}\n"
    },
    "contracts/agent/interfaces/IAllowanceStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IAllowanceStrategy {\n    function set(\n        address owner,\n        address buyer,\n        bytes memory args\n    ) external;\n\n    function checkAllowances(\n        address owner,\n        address buyer,\n        uint[] memory ids,\n        uint[] memory amounts\n    ) external;\n\n    function allowanceOfBatch(\n        address owner,\n        address buyer,\n        uint[] memory ids\n    ) external view returns(uint[] memory);\n}\n"
    },
    "contracts/agent/facets/MortgageFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport '@solidstate/contracts/introspection/ERC165.sol';\nimport '@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol';\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport '../../shared/lib/Util.sol';\nimport '../../shared/lib/LibPausable.sol';\nimport '../lib/AppStorage.sol';\nimport '../../shared/lib/LibInitializable.sol';\n\n/**\n * @title MortgageFacet\n * @author Shu Dong, Yijie Hong\n * @notice Facet contract holding functions for miners to manage mortgage.\n * @notice Facet contract currently only supports weekly NFT token.\n * @dev the contract also implements IERC1155Receiver to receive and lock demine nft\n */\ncontract MortgageFacet is\n    Initializable,\n    PausableModifier,\n    IERC1155Receiver,\n    StorageBase,\n    ERC165\n{\n    using SafeERC20 for IERC20;\n\n    function init(\n        address nftAddr,\n        address paymentTokenAddr,\n        address custodianAddr,\n        uint costPerToken\n    ) external onlyInitializing {\n        IERC1155Rewardable nftContract = IERC1155Rewardable(nftAddr);\n        s.nft = nftContract;\n        s.paymentToken = paymentTokenAddr;\n        s.custodian = custodianAddr;\n        s.tokenCost = costPerToken;\n    }\n\n    /**\n     * @notice Pay token cost and liquidize tokens\n     * @param ids DeMine nft token ids to redeem\n     * @param amounts Amount of each demine nft token\n     */\n    function redeemNFT(\n        uint256[] calldata ids,\n        uint[] calldata amounts\n    ) external whenNotPaused {\n        require(\n            ids.length == amounts.length,\n            \"DeMineAgent: array length mismatch\"\n        );\n        uint costPerToken = s.tokenCost;\n\n        uint totalCost;\n        for (uint i = 0; i < ids.length; i++) {\n            totalCost += costPerToken * amounts[i] * daysInToken(ids[i]);\n            uint balance = s.balances[ids[i]][msg.sender];\n            require(balance > 0 && balance > amounts[i], 'DeMineAgent: no sufficient balance');\n            s.balances[ids[i]][msg.sender] = balance - amounts[i];\n        }\n        if (totalCost > 0) {\n            IERC20(s.paymentToken).safeTransferFrom(msg.sender, s.custodian, totalCost);\n        }\n        s.nft.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    function balanceOfBatch(\n        address account,\n        uint256[] calldata ids\n    ) external view returns(uint[] memory) {\n        uint[] memory balances = new uint[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            balances[i] = s.balances[ids[i]][account];\n        }\n        return balances;\n    }\n\n    function billingStatementOfBatch(\n        uint[] calldata tokenIds\n    ) external view returns(BillingStatement[] memory) {\n        BillingStatement[] memory res = new BillingStatement[](tokenIds.length);\n        for (uint i = 0; i < tokenIds.length; i++) {\n            res[i] = s.statements[tokenIds[i]];\n        }\n        return res;\n    }\n\n    function nft() external view returns(address) {\n        return address(s.nft);\n    }\n\n    function custodian() external view returns(address) {\n        return s.custodian;\n    }\n\n    function paymentToken() external view returns(address) {\n        return s.paymentToken;\n    }\n\n    function tokenCost() external view returns(uint) {\n        return s.tokenCost;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0; // reject\n    }\n\n    // @dev the function should only be called by mint function of DeMineNFT\n    // @param from Must be address(0)\n    // @param data Must be encoded address of mortagager\n    function onERC1155BatchReceived(\n        address,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(\n            from == s.nft.custodian(),\n            'DeMineAgent: only tokens from custodian allowed'\n        );\n        (address mortgager) = abi.decode(data, (address));\n        for (uint i = 0; i < ids.length; i++) {\n            uint balance = s.balances[ids[i]][mortgager] + amounts[i];\n            s.balances[ids[i]][mortgager] = balance;\n        }\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @notice Withdraw surplus or payoff debt for NFT tokens that have been billed.\n     *         All balances of ids need to be paid off or withdrawn. Partial payoff\n     *         or withdraw is not supported.\n     */\n    function withdrawAndPayoff(\n        uint256[] calldata ids\n    ) external whenNotPaused {\n        uint income;\n        uint debt;\n\n        for (uint i = 0; i < ids.length; i++) {\n            BillingStatement memory st = s.statements[ids[i]];\n            uint balance = s.balances[ids[i]][msg.sender];\n            income += st.surplus * balance / st.balance;\n            debt += st.debt * balance / st.balance;\n            delete s.balances[ids[i]][msg.sender];\n        }\n\n        if (debt > 0) {\n            IERC20(s.paymentToken).safeTransferFrom(s.custodian, msg.sender, debt);\n        }\n        if (income > 0) {\n            IERC20(s.nft.earningToken()).safeTransfer(msg.sender, income);\n        }\n    }\n\n    function tokenIdToStart(uint256 tokenId) private pure returns(uint128) {\n        return uint128(tokenId >> 128);\n    }\n\n    function tokenIdToEnd(uint256 tokenId) private pure returns(uint128) {\n        return uint128(tokenId);\n    }\n\n    function daysInToken(uint256 tokenId) private pure returns(uint) {\n        return (tokenIdToEnd(tokenId) - tokenIdToStart(tokenId)) / 86400;\n    }\n\n    function getTokenCost() external view returns(uint) {\n        return s.tokenCost;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from './IERC165.sol';\nimport { ERC165Storage } from './ERC165Storage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n    using ERC165Storage for ERC165Storage.Layout;\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/shared/lib/LibInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@solidstate/contracts/utils/AddressUtils.sol';\n\n/**\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary InitializableStorage {\n    struct Layout {\n        bool initialized;\n        bool initializing;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.contracts.storage.Initializable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract Initializable {\n    modifier initializer() {\n        InitializableStorage.Layout storage l = InitializableStorage.layout();\n        require(\n            l.initializing ? isConstructor() : !l.initialized,\n            'Initializable: contract is already initialized'\n        );\n        bool isTopLevelCall = !l.initializing;\n        if (isTopLevelCall) {\n            l.initializing = true;\n            l.initialized = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            l.initializing = false;\n        }\n    }\n\n    modifier onlyInitializing() {\n        require(\n            InitializableStorage.layout().initializing,\n            'Initializable: contract is not initializing'\n        );\n        _;\n    }\n\n    function isConstructor() private view returns (bool) {\n        return !AddressUtils.isContract(address(this));\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}