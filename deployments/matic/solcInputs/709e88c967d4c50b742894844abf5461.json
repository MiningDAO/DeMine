{
  "language": "Solidity",
  "sources": {
    "contracts/shared/DeMineERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport '@solidstate/contracts/access/SafeOwnable.sol';\nimport '@solidstate/contracts/token/ERC20/ERC20.sol';\nimport '@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol';\nimport '@solidstate/contracts/factory/CloneFactory.sol';\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport './lib/LibPausable.sol';\nimport './lib/LibInitializable.sol';\n\ncontract DeMineERC20 is\n    Pausable,\n    Initializable,\n    SafeOwnable,\n    ERC20\n{\n    event Clone(address indexed from, address indexed cloned);\n\n    using OwnableStorage for OwnableStorage.Layout;\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address owner\n    ) external initializer {\n        OwnableStorage.layout().setOwner(owner);\n        ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\n        l.name = name;\n        l.symbol = symbol;\n        l.decimals = decimals;\n    }\n\n    function create(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address owner\n    ) external {\n        address cloned = Clones.clone(address(this));\n        DeMineERC20(payable(cloned)).initialize(name, symbol, decimals, owner);\n        emit Clone(address(this), cloned);\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    function nomineeOwner() public view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @inheritdoc Ownable\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20Base } from './base/ERC20Base.sol';\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\n\n/**\n * @title SolidState ERC20 implementation, including recommended extensions\n */\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setName(Layout storage l, string memory name) internal {\n        l.name = name;\n    }\n\n    function setSymbol(Layout storage l, string memory symbol) internal {\n        l.symbol = symbol;\n    }\n\n    function setDecimals(Layout storage l, uint8 decimals) internal {\n        l.decimals = decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/factory/CloneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Factory } from './Factory.sol';\n\n/**\n * @title Factory for contract self-replication\n * @dev derived from https://github.com/ItsNickBarry/solidity-auto-deployer (MIT license)\n */\nabstract contract CloneFactory is Factory {\n    bytes private constant CLONE_INIT_CODE = hex'58333b90818180333cf3';\n    bytes32 private constant CLONE_INIT_CODE_HASH = keccak256(CLONE_INIT_CODE);\n\n    /**\n     * @notice deploy a clone of the calling contract using \"CREATE\" opcode\n     * @return cloneContract address of deployed contract\n     */\n    function _deployClone() internal returns (address cloneContract) {\n        return _deploy(CLONE_INIT_CODE);\n    }\n\n    /**\n     * @notice deploy a clone of the calling contract using \"CREATE2\" opcode\n     * @dev reverts if deployment is not successful (likely because salt has already been used)\n     * @param salt input for deterministic address calculation\n     * @return cloneContract address of deployed contract\n     */\n    function _deployClone(bytes32 salt)\n        internal\n        returns (address cloneContract)\n    {\n        return _deploy(CLONE_INIT_CODE, salt);\n    }\n\n    /**\n     * @notice calculate the deployment address for a given salt\n     * @param salt input for deterministic address calculation\n     * @return deployment address\n     */\n    function _calculateCloneDeploymentAddress(bytes32 salt)\n        internal\n        view\n        returns (address)\n    {\n        return _calculateDeploymentAddress(CLONE_INIT_CODE_HASH, salt);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/shared/lib/LibPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/access/OwnableInternal.sol';\nimport '../interfaces/IPausable.sol';\n\nlibrary LibPausable {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract PausableModifier {\n    modifier whenPaused() {\n        require(LibPausable.layout().paused, 'Pausable: not paused');\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!LibPausable.layout().paused, 'Pausable: paused');\n        _;\n    }\n}\n\nabstract contract Pausable is IPausable, OwnableInternal {\n    function paused() external override view returns (bool) {\n        return LibPausable.layout().paused;\n    }\n\n    function pause() external onlyOwner override {\n        LibPausable.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyOwner override {\n        LibPausable.layout().paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "contracts/shared/lib/LibInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport '@solidstate/contracts/utils/AddressUtils.sol';\n\n/**\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary InitializableStorage {\n    struct Layout {\n        bool initialized;\n        bool initializing;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('demine.contracts.storage.Initializable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract Initializable {\n    modifier initializer() {\n        InitializableStorage.Layout storage l = InitializableStorage.layout();\n        require(\n            l.initializing ? isConstructor() : !l.initialized,\n            'Initializable: contract is already initialized'\n        );\n        bool isTopLevelCall = !l.initializing;\n        if (isTopLevelCall) {\n            l.initializing = true;\n            l.initialized = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            l.initializing = false;\n        }\n    }\n\n    modifier onlyInitializing() {\n        require(\n            InitializableStorage.layout().initializing,\n            'Initializable: contract is not initializing'\n        );\n        _;\n    }\n\n    function isConstructor() private view returns (bool) {\n        return !AddressUtils.isContract(address(this));\n    }\n}\n"
    },
    "@solidstate/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from './IERC173.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IERC173, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual override returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal {\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        require(\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\n            'SafeOwnable: sender must be nominee owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    },
    "@solidstate/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from '../IERC20.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(address holder, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = ERC20BaseStorage.layout().allowances[holder][\n            msg.sender\n        ];\n        require(\n            currentAllowance >= amount,\n            'ERC20: transfer amount exceeds allowance'\n        );\n        unchecked {\n            _approve(holder, msg.sender, currentAllowance - amount);\n        }\n        _transfer(holder, recipient, amount);\n        return true;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20Base, ERC20BaseStorage } from '../base/ERC20Base.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is ERC20Base {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        unchecked {\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\n                .layout()\n                .allowances[msg.sender];\n\n            uint256 allowance = allowances[spender];\n            require(\n                allowance + amount >= allowance,\n                'ERC20Extended: excessive allowance'\n            );\n\n            _approve(\n                msg.sender,\n                spender,\n                allowances[spender] = allowance + amount\n            );\n\n            return true;\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        unchecked {\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\n                .layout()\n                .allowances[msg.sender];\n\n            uint256 allowance = allowances[spender];\n            require(\n                amount <= allowance,\n                'ERC20Extended: insufficient allowance'\n            );\n\n            _approve(\n                msg.sender,\n                spender,\n                allowances[spender] = allowance - amount\n            );\n\n            return true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\nimport { IERC20Metadata } from './IERC20Metadata.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() public view virtual override returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(address holder, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20Internal } from '../IERC20Internal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(address account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        require(balance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(holder != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        require(\n            holderBalance >= amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Factory for arbitrary code deployment using the \"CREATE\" and \"CREATE2\" opcodes\n */\nabstract contract Factory {\n    /**\n     * @notice deploy contract code using \"CREATE\" opcode\n     * @param initCode contract initialization code\n     * @return deployment address of deployed contract\n     */\n    function _deploy(bytes memory initCode)\n        internal\n        returns (address deployment)\n    {\n        assembly {\n            let encoded_data := add(0x20, initCode)\n            let encoded_size := mload(initCode)\n            deployment := create(0, encoded_data, encoded_size)\n        }\n\n        require(deployment != address(0), 'Factory: failed deployment');\n    }\n\n    /**\n     * @notice deploy contract code using \"CREATE2\" opcode\n     * @dev reverts if deployment is not successful (likely because salt has already been used)\n     * @param initCode contract initialization code\n     * @param salt input for deterministic address calculation\n     * @return deployment address of deployed contract\n     */\n    function _deploy(bytes memory initCode, bytes32 salt)\n        internal\n        returns (address deployment)\n    {\n        assembly {\n            let encoded_data := add(0x20, initCode)\n            let encoded_size := mload(initCode)\n            deployment := create2(0, encoded_data, encoded_size, salt)\n        }\n\n        require(deployment != address(0), 'Factory: failed deployment');\n    }\n\n    /**\n     * @notice calculate the _deployMetamorphicContract deployment address for a given salt\n     * @param initCodeHash hash of contract initialization code\n     * @param salt input for deterministic address calculation\n     * @return deployment address\n     */\n    function _calculateDeploymentAddress(bytes32 initCodeHash, bytes32 salt)\n        internal\n        view\n        returns (address)\n    {\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                hex'ff',\n                                address(this),\n                                salt,\n                                initCodeHash\n                            )\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "contracts/shared/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IPausable {\n    /**\n     * @dev Emitted when paused by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when unpaused by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev Should return if the contract is paused\n     */\n    function paused() external view returns (bool);\n\n    /**\n     * @dev pause the contract\n     */\n    function pause() external;\n\n    /**\n     * @dev unpause the contract\n     */\n    function unpause() external;\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}